<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>anacore.vcf &mdash; AnaCore  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/anacore.css?v=93b82d15" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            AnaCore
              <img src="../../_static/anacore_logo_40deg.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../anacore.html">AnaCore package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">AnaCore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">anacore.vcf</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for anacore.vcf</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Classes and functions for reading/writing/processing VCF.</span>

<span class="sd">:Example:</span>

<span class="sd">    Read VCF by line</span>

<span class="sd">    .. highlight:: python</span>
<span class="sd">    .. code-block:: python</span>

<span class="sd">        from anacore.vcf import VCFIO</span>

<span class="sd">        with VCFIO(&quot;test.vcf.gz&quot;) as reader:</span>
<span class="sd">            print(&quot;Variant&quot;, &quot;\\t&quot;.join(reader.samples), sep=&quot;\\t&quot;)</span>
<span class="sd">            for record in reader:</span>
<span class="sd">                alt_freq = [str(record.getAF(curr_spl)) for curr_spl in reader.samples]</span>
<span class="sd">                print(record.getName(), &quot;\\t&quot;.join(alt_freq), sep=&quot;\\t&quot;)</span>

<span class="sd">        # Result&gt;</span>
<span class="sd">        # Variant\tN01\tN02\tN03</span>
<span class="sd">        # chr1:35-35=A/T\t0.3\t0.4\t0.1</span>
<span class="sd">        # chr1:128-128=G/A\t0.1\t0.6\t0.05</span>

<span class="sd">    Read VCF by coordinate</span>

<span class="sd">    .. highlight:: python</span>
<span class="sd">    .. code-block:: python</span>

<span class="sd">        from anacore.vcf import VCFIO</span>

<span class="sd">        with VCFIO(&quot;test.vcf.gz&quot;, &quot;i&quot;) as reader:</span>
<span class="sd">            for record in reader.getSub(&quot;chr1&quot;, 10, 100):</span>
<span class="sd">                print(record.getName())</span>

<span class="sd">        # Result&gt;</span>
<span class="sd">        # chr1:35-35=A/T</span>

<span class="sd">    Write VCF</span>

<span class="sd">    .. highlight:: python</span>
<span class="sd">    .. code-block:: python</span>

<span class="sd">        from anacore.vcf import VCFIO</span>

<span class="sd">        with VCFIO(&quot;test.vcf.gz&quot;, &quot;w&quot;) as writer:</span>
<span class="sd">            # Header</span>
<span class="sd">            writer.samples = [&quot;my_sample&quot;]</span>
<span class="sd">            writer.filter = [</span>
<span class="sd">                {&quot;q10&quot;: HeaderFilterAttr(&quot;q10&quot;, &quot;Quality below 10&quot;)}</span>
<span class="sd">            ]</span>
<span class="sd">            self.info = {</span>
<span class="sd">                &quot;DB&quot;: HeaderInfoAttr(&quot;DB&quot;, &quot;dbSNP membership, build 129&quot;, &quot;Flag&quot;, 0)</span>
<span class="sd">            }</span>
<span class="sd">            self.format = {</span>
<span class="sd">                &quot;AF&quot;: HeaderFormatAttr(&quot;AF&quot;, &quot;Allele Frequency&quot;, &quot;Float&quot;, &quot;A&quot;)</span>
<span class="sd">            }</span>
<span class="sd">            writer.extra_header = [</span>
<span class="sd">                &quot;##source=myImputationProgramV3.1&quot;,</span>
<span class="sd">                &quot;##phasing=partial&quot;</span>
<span class="sd">            ]</span>
<span class="sd">            writer.writeHeader()</span>
<span class="sd">            # Record</span>
<span class="sd">            for record in vcf_record_list:</span>
<span class="sd">                writer.write(record)</span>

<span class="sd">        # Result&gt;</span>
<span class="sd">        # ##fileformat=VCFv4.3</span>
<span class="sd">        # ##source=myImputationProgramV3.1</span>
<span class="sd">        # ##phasing=partial</span>
<span class="sd">        # ##INFO=&lt;ID=DB,Number=0,Type=Flag,Description=&quot;dbSNP membership, build 129&quot;&gt;</span>
<span class="sd">        # ##FILTER=&lt;ID=q10,Description=&quot;Quality below 10&quot;&gt;</span>
<span class="sd">        # ##FORMAT=&lt;ID=AF,Number=A,Type=Float,Description=&quot;Allele Frequency&quot;&gt;</span>
<span class="sd">        # #CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\tmy_sample</span>
<span class="sd">        # chr1\t35\t.\tA\tT.\tPASS\tDB\tAF\t0.1</span>
<span class="sd">        # ...</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Frederic Escudie&#39;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s1">&#39;Copyright (C) 2017 CHU Toulouse&#39;</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s1">&#39;GNU General Public License&#39;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s1">&#39;1.35.0&#39;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s1">&#39;escudie.frederic@iuct-oncopole.fr&#39;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s1">&#39;prod&#39;</span>

<span class="kn">from</span> <span class="nn">anacore.abstractFile</span> <span class="kn">import</span> <span class="n">AbstractFile</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">pysam</span> <span class="kn">import</span> <span class="n">TabixFile</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>


<div class="viewcode-block" id="decodeInfoValue"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.decodeInfoValue">[docs]</a><span class="k">def</span> <span class="nf">decodeInfoValue</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return text where special characters was unescaped. This method is used to read values coming from INFO or FORMAT.</span>

<span class="sd">    :param val: A string value of an item of INFO or FORMAT.</span>
<span class="sd">    :type val: str</span>
<span class="sd">    :return: Text where special characters was unescaped (%3A, %3B, %3D, %2C).</span>
<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;%&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">val</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;%3A&quot;</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;%3B&quot;</span><span class="p">,</span> <span class="s2">&quot;;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;%3D&quot;</span><span class="p">,</span> <span class="s2">&quot;=&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;%2C&quot;</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="encodeInfoValue"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.encodeInfoValue">[docs]</a><span class="k">def</span> <span class="nf">encodeInfoValue</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return text where special characters was escaped. This method is used to write values coming from INFO or FORMAT.</span>

<span class="sd">    :param val: A string value of an item of INFO or FORMAT.</span>
<span class="sd">    :type val: str</span>
<span class="sd">    :return: Text where special characters was escaped (:, ;, =, ,).</span>
<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;%3A&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">,</span> <span class="s2">&quot;%3B&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="s2">&quot;%3D&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;%2C&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="getHeaderAttr"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.getHeaderAttr">[docs]</a><span class="k">def</span> <span class="nf">getHeaderAttr</span><span class="p">(</span><span class="n">header_line</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an instance of HeaderAttr or a child corresponding to the VCF line.</span>

<span class="sd">    :param header_line: Declaration line declaration of an VCF attributes from the VCF header.</span>
<span class="sd">    :type header_line: str</span>
<span class="sd">    :return: An instance of HeaderAttr or a child corresponding to the VCF line.</span>
<span class="sd">    :rtype: HeaderAttr or a child</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get content</span>
    <span class="n">header_category</span><span class="p">,</span> <span class="n">header_content</span> <span class="o">=</span> <span class="n">header_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># ##INFO=&lt;ID=AD,Version=&quot;1&quot;&gt;</span>
    <span class="n">header_category</span> <span class="o">=</span> <span class="n">header_category</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>  <span class="c1"># ##INFO to INFO</span>
    <span class="n">header_content</span> <span class="o">=</span> <span class="n">header_content</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># &lt;ID=AD,Version=&quot;1&quot;&gt; to ID=AD,Version=&quot;1&quot;</span>
    <span class="c1"># Get attributes</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">attributes_cases</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">opened_quote</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">curr_char</span> <span class="ow">in</span> <span class="n">header_content</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">curr_char</span> <span class="o">==</span> <span class="s2">&quot;,&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">opened_quote</span><span class="p">:</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="n">key</span><span class="o">.</span><span class="n">capitalize</span><span class="p">():</span>  <span class="c1"># Keep case different of capitalize</span>
                <span class="n">attributes_cases</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span> <span class="o">=</span> <span class="n">key</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">opened_quote</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">curr_char</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">:</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;&quot;&#39;</span>  <span class="c1"># replace &#39;\&quot;&#39; by &#39;&quot;&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">opened_quote</span><span class="p">:</span>  <span class="c1"># The quote is the second</span>
                    <span class="n">opened_quote</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># The quote is the first</span>
                    <span class="n">opened_quote</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stack</span> <span class="o">+=</span> <span class="n">curr_char</span>
    <span class="k">if</span> <span class="n">stack</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="n">key</span><span class="o">.</span><span class="n">capitalize</span><span class="p">():</span>  <span class="c1"># Keep case different of capitalize</span>
            <span class="n">attributes_cases</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span> <span class="o">=</span> <span class="n">key</span>
    <span class="c1"># Return</span>
    <span class="n">header_class_name</span> <span class="o">=</span> <span class="s2">&quot;Header</span><span class="si">{}</span><span class="s2">Attr&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">header_category</span><span class="o">.</span><span class="n">capitalize</span><span class="p">())</span>
    <span class="n">header_class</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">],</span> <span class="n">header_class_name</span><span class="p">)</span>
    <span class="n">attr</span> <span class="o">=</span> <span class="n">header_class</span><span class="p">(</span><span class="o">**</span><span class="n">attributes</span><span class="p">)</span>
    <span class="n">attr</span><span class="o">.</span><span class="n">case_by_attr</span> <span class="o">=</span> <span class="n">attributes_cases</span>
    <span class="k">return</span> <span class="n">attr</span></div>


<div class="viewcode-block" id="HeaderAttr"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.HeaderAttr">[docs]</a><span class="k">class</span> <span class="nc">HeaderAttr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to manage a dict attribute of the VCF header: one tag FORMAT, one tag INFO, one tag FILTER ...&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of HeaderAttr.</span>

<span class="sd">        :param id: Identifier of the attribute.</span>
<span class="sd">        :type id: str</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: HeaderAttr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s2">&quot;datastore&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_required_attr</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ID&quot;</span><span class="p">]</span>  <span class="c1"># List of required attributes names.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_without_quote</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;ID&quot;</span><span class="p">}</span>  <span class="c1"># List of required attributes without quote in str value.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">case_by_attr</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Store case sensitive title for extra attributes if it is different of capitalized attribute name.</span>

<div class="viewcode-block" id="HeaderAttr.keys"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.HeaderAttr.keys">[docs]</a>    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of the attribute’s keys.</span>

<span class="sd">        :return: list of the attribute’s keys.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datastore</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span></div>

<div class="viewcode-block" id="HeaderAttr.items"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.HeaderAttr.items">[docs]</a>    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of the dictionary’s items ((key, value) pairs).</span>

<span class="sd">        :return: List of the dictionary’s items.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datastore</span><span class="o">.</span><span class="n">items</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="fm">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;_&quot;</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;case_by_attr&quot;</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">datastore</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">delattr</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign value to the attribute.</span>

<span class="sd">        :param name: The attribute name.</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param value: The value to be assigned to the attribute.</span>
<span class="sd">        :type value: *</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;_&quot;</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;case_by_attr&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">datastore</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;_&quot;</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;case_by_attr&quot;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datastore</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pre_attr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_required_attr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_without_quote</span><span class="p">:</span>
                <span class="n">pre_attr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datastore</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pre_attr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=&quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datastore</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&quot;&#39;</span><span class="p">)))</span>
        <span class="n">extra_keys</span> <span class="o">=</span> <span class="p">{</span><span class="n">elt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span> <span class="o">-</span> <span class="p">{</span><span class="n">elt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_required_attr</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">extra_keys</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">extra_keys</span><span class="p">):</span>
                <span class="n">title</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">case_by_attr</span><span class="p">:</span>
                    <span class="n">title</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">case_by_attr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">pre_attr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=&quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datastore</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&quot;&#39;</span><span class="p">)))</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pre_attr</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datastore</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span></div>


<div class="viewcode-block" id="HeaderDescAttr"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.HeaderDescAttr">[docs]</a><span class="k">class</span> <span class="nc">HeaderDescAttr</span><span class="p">(</span><span class="n">HeaderAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to manage VCF header attribute where ID and Description are required.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of HeaderDescAttr.</span>

<span class="sd">        :param id: Identifier of the attribute.</span>
<span class="sd">        :type id: str</span>
<span class="sd">        :param description: Description of the attribute.</span>
<span class="sd">        :type description: str</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: HeaderDescAttr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">description</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_required_attr</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ID&quot;</span><span class="p">,</span> <span class="s2">&quot;Description&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign value to the attribute.</span>

<span class="sd">        :param name: The attribute name.</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param value: The value to be assigned to the attribute.</span>
<span class="sd">        :type value: *</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="HeaderTypedAttr"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.HeaderTypedAttr">[docs]</a><span class="k">class</span> <span class="nc">HeaderTypedAttr</span><span class="p">(</span><span class="n">HeaderDescAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to manage VCF header attribute where ID, Description, Type and Number are required.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;String&quot;</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of HeaderTypedAttr.</span>

<span class="sd">        :param id: Identifier of the attribute.</span>
<span class="sd">        :type id: str</span>
<span class="sd">        :param description: Description of the attribute.</span>
<span class="sd">        :type description: str</span>
<span class="sd">        :param type: Data types. Authorized values: Integer (32-bit, signed), Float (32-bit IEEE-754),Flag, Character, or String.</span>
<span class="sd">        :type type: str</span>
<span class="sd">        :param number: Number of values that can be included with the field.</span>
<span class="sd">        :type number: char</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: HeaderTypedAttr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_required_attr</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ID&quot;</span><span class="p">,</span> <span class="s2">&quot;Number&quot;</span><span class="p">,</span> <span class="s2">&quot;Type&quot;</span><span class="p">,</span> <span class="s2">&quot;Description&quot;</span><span class="p">]</span>  <span class="c1"># List of required attributes names.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_without_quote</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;ID&quot;</span><span class="p">,</span> <span class="s2">&quot;Number&quot;</span><span class="p">,</span> <span class="s2">&quot;Type&quot;</span><span class="p">}</span>  <span class="c1"># List of required attributes without quote in str value.</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign value to the attribute.</span>

<span class="sd">        :param name: The attribute name.</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param value: The value to be assigned to the attribute.</span>
<span class="sd">        :type value: *</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span>
            <span class="n">type_fct</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;String&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                <span class="s2">&quot;Integer&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                <span class="s2">&quot;Float&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                <span class="s2">&quot;Character&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                <span class="s2">&quot;Flag&quot;</span><span class="p">:</span> <span class="kc">None</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="o">=</span> <span class="n">type_fct</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;number&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_number</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="HeaderFilterAttr"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.HeaderFilterAttr">[docs]</a><span class="k">class</span> <span class="nc">HeaderFilterAttr</span><span class="p">(</span><span class="n">HeaderDescAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to manage a FILTER attribute of VCF header.&quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="HeaderFormatAttr"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.HeaderFormatAttr">[docs]</a><span class="k">class</span> <span class="nc">HeaderFormatAttr</span><span class="p">(</span><span class="n">HeaderTypedAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to manage a FORMAT attribute of VCF header.&quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="HeaderInfoAttr"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.HeaderInfoAttr">[docs]</a><span class="k">class</span> <span class="nc">HeaderInfoAttr</span><span class="p">(</span><span class="n">HeaderTypedAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to manage an INFO attribute of VCF header.&quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="HeaderSampleAttr"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.HeaderSampleAttr">[docs]</a><span class="k">class</span> <span class="nc">HeaderSampleAttr</span><span class="p">(</span><span class="n">HeaderAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to manage an SAMPLE attribute of VCF header.&quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="VCFRecord"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord">[docs]</a><span class="k">class</span> <span class="nc">VCFRecord</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to manage a variant record.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
          <span class="bp">self</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">knownSNPId</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">refAllele</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">altAlleles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qual</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pFilter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pFormat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of VCFRecord.</span>

<span class="sd">        :param region: Identifier of the reference region/contig/chromosome containing the variant (example: chr3).</span>
<span class="sd">        :type region: str</span>
<span class="sd">        :param position: Start position for the variant (1-based).</span>
<span class="sd">        :type position: int</span>
<span class="sd">        :param knownSNPId: Semi-colon separated list of unique identifiers where available (example rs numbers from dbSNP).</span>
<span class="sd">        :type knownSNPId: str</span>
<span class="sd">        :param refAllele: Reference allele.</span>
<span class="sd">        :type refAllele: char</span>
<span class="sd">        :param altAlleles: Alternatives alleles.</span>
<span class="sd">        :type altAlleles: list</span>
<span class="sd">        :param qual: Variant quality.</span>
<span class="sd">        :type qual: int</span>
<span class="sd">        :param pFilter: List of filter tags. It can be in three possible states: (1) if no filter was applied, the field contains an empty list (&quot;.&quot; in VCF file); (2) if filters were applied but the record passes filters, the field should contain [&quot;PASS&quot;]; (3) if filters were applied and the record does not pass filters, the field should contain [&quot;filter_name&quot;, ...].</span>
<span class="sd">        :type pFilter: list</span>
<span class="sd">        :param info: Variant additionnal information.</span>
<span class="sd">        :type info: dict</span>
<span class="sd">        :param pFormat: List of format tags.</span>
<span class="sd">        :type pFormat: list</span>
<span class="sd">        :param samples: Variant format information by sample.</span>
<span class="sd">        :type samples: dict</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: VCFRecord</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="n">region</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">knownSNPId</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">refAllele</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alt</span> <span class="o">=</span> <span class="n">altAlleles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qual</span> <span class="o">=</span> <span class="n">qual</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span> <span class="k">if</span> <span class="n">pFilter</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pFilter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> <span class="k">if</span> <span class="n">info</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span> <span class="k">if</span> <span class="n">pFormat</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pFormat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="VCFRecord.getEmptyAlleleMarker"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.getEmptyAlleleMarker">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">getEmptyAlleleMarker</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the marker internally used to represent an empty allele (reference allele in insertion and alternative allele in deletion).</span>

<span class="sd">        :return: The marker.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;-&quot;</span></div>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign value to the attribute.</span>

<span class="sd">        :param name: The attribute name.</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param value: The value to be assigned to the attribute.</span>
<span class="sd">        :type value: *</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;ref&quot;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">()</span> <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="n">value</span><span class="p">)</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">VCFRecord</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s2">&quot;_normalized&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;alt&quot;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">[(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">()</span> <span class="k">if</span> <span class="n">elt</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="n">elt</span><span class="p">)</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">VCFRecord</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s2">&quot;_normalized&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;pos&quot;</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;chrom&quot;</span><span class="p">:</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">VCFRecord</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s2">&quot;_normalized&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">VCFRecord</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="VCFRecord.containsIndel"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.containsIndel">[docs]</a>    <span class="k">def</span> <span class="nf">containsIndel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the variant contains an allele corresponding to an insertion or a deletion.</span>

<span class="sd">        :return: True if the variant contains an allele corresponding to an insertion or a deletion.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :note: If the alternative allele and the reference alle have the same length the variant is considered as a substitution. For example: AA/GC is considered as double substitution and not as double insertion after double deletion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">contains_indel</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">(),</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">alt</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_alt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">(),</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">curr_alt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">allele</span> <span class="ow">in</span> <span class="n">alt</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">allele</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">):</span>
                <span class="n">contains_indel</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">contains_indel</span></div>

<div class="viewcode-block" id="VCFRecord.refStart"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.refStart">[docs]</a>    <span class="k">def</span> <span class="nf">refStart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first position on reference affected by the alternative allele.</span>

<span class="sd">        :return: The first position on reference affected by the alternative allele. For an insertion between two nucleotids the value will be: first nucleotids pos + 0.5.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        :examples:</span>
<span class="sd">                # Insertion:</span>
<span class="sd">                chr1  12  A    TG    =&gt; returns 12</span>
<span class="sd">                chr1  12  A    AGT   =&gt; chr1  13  .   GT  (std) =&gt; returns 12.5</span>
<span class="sd">                chr1  11  AA   AGT   =&gt; chr1  12  A   GT  (std) =&gt; returns 12</span>
<span class="sd">                chr1  10  AAA  AAGT  =&gt; chr1  12  A   GT  (std) =&gt; returns 12</span>
<span class="sd">                chr1  10  AATC AACGT =&gt; chr1  12  TC  CGT (std) =&gt; returns 12</span>

<span class="sd">                # Substitution:</span>
<span class="sd">                chr1  10  A   T  =&gt; returns 10</span>
<span class="sd">                chr1  10  AA  TT =&gt; returns 10</span>

<span class="sd">                # Deletion:</span>
<span class="sd">                chr1  12  A     .  =&gt; returns 12</span>
<span class="sd">                chr1  10  AAA   .  =&gt; returns 10</span>
<span class="sd">                chr1  10  AAA   A  =&gt; chr1  11  AA  . (std) =&gt; returns 11</span>
<span class="sd">                chr1  10  AGC   A  =&gt; chr1  11  GC  . (std) =&gt; returns 11</span>
<span class="sd">                chr1  10  AAAT  TG =&gt; returns 10</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The function &#39;refStart&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span><span class="o">.</span><span class="n">normalizeSingleAllele</span><span class="p">()</span>
        <span class="n">record</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">pos</span>
        <span class="k">if</span> <span class="n">record</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">():</span>
            <span class="n">start</span> <span class="o">-=</span> <span class="mf">0.5</span>
        <span class="k">return</span> <span class="n">start</span></div>

<div class="viewcode-block" id="VCFRecord.refEnd"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.refEnd">[docs]</a>    <span class="k">def</span> <span class="nf">refEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the last position on reference affected by the alternative allele.</span>

<span class="sd">        :return: The last position on reference affected by the alternative allele. For an insertion between two nucleotids the value will be: first nucleotids pos + 0.5.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        :examples:</span>
<span class="sd">                # Insertion:</span>
<span class="sd">                chr1  12  A    TG    =&gt; returns 12</span>
<span class="sd">                chr1  12  A    AGT   =&gt; chr1  13  -   GT  (std) =&gt; returns 12.5</span>
<span class="sd">                chr1  11  AA   AGT   =&gt; chr1  12  A   GT  (std) =&gt; returns 12</span>
<span class="sd">                chr1  10  AAA  AAGT  =&gt; chr1  12  A   GT  (std) =&gt; returns 12</span>
<span class="sd">                chr1  10  AATC AACGT =&gt; chr1  12  TC  CGT (std) =&gt; returns 13</span>

<span class="sd">                # Substitution:</span>
<span class="sd">                chr1  10  A   T  =&gt; returns 10</span>
<span class="sd">                chr1  10  AA  TT =&gt; returns 11</span>

<span class="sd">                # Deletion:</span>
<span class="sd">                chr1  12  A     -  =&gt; returns 12</span>
<span class="sd">                chr1  10  AAA   -  =&gt; returns 12</span>
<span class="sd">                chr1  10  AAA   A  =&gt; chr1  11  AA  - (std) =&gt; returns 12</span>
<span class="sd">                chr1  10  AGC   A  =&gt; chr1  11  GC  - (std) =&gt; returns 12</span>
<span class="sd">                chr1  10  AAAT  TG =&gt; returns 13</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The function &#39;refEnd&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span><span class="o">.</span><span class="n">normalizeSingleAllele</span><span class="p">()</span>
        <span class="n">record</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">pos</span>
        <span class="k">if</span> <span class="n">record</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">():</span>
            <span class="n">end</span> <span class="o">-=</span> <span class="mf">0.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">end</span></div>

<div class="viewcode-block" id="VCFRecord.getName"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.getName">[docs]</a>    <span class="k">def</span> <span class="nf">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an unique name to identified the variant.</span>

<span class="sd">        :return: The variant name.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">=</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span>
            <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="VCFRecord.isDeletion"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.isDeletion">[docs]</a>    <span class="k">def</span> <span class="nf">isDeletion</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the variant is a deletion.</span>

<span class="sd">        :return: True if the variant is a deletion.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        :note: If the alternative allele and the reference allele have the same length the variant is considered as a substitution. For example: AA/GC is considered as double substitution and not as double insertion after double deletion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The function &#39;isDeletion&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="n">is_deletion</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">(),</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">alt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">(),</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">):</span>
            <span class="n">is_deletion</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">is_deletion</span></div>

<div class="viewcode-block" id="VCFRecord.isInsAndDel"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.isInsAndDel">[docs]</a>    <span class="k">def</span> <span class="nf">isInsAndDel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the variant is an insertion and also a deletion.</span>

<span class="sd">        :return: True if the variant is an insertion and also a deletion.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The function &#39;isInsAndDel&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="n">is_ins_and_del</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span><span class="o">.</span><span class="n">normalizeSingleAllele</span><span class="p">()</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">(),</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">alt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">(),</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt</span><span class="p">):</span>  <span class="c1"># Deletion exists and is more longer (eg: AT/ or AT/G)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Insertion exists (eg: AT/G)</span>
                <span class="n">is_ins_and_del</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt</span><span class="p">):</span>  <span class="c1"># Insertion exists and is more longer (eg: /AT or G/AT)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Deletion exists (eg: G/AT)</span>
                <span class="n">is_ins_and_del</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Same length: SNV or MNV</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># MNV: AT/GC</span>
                <span class="n">is_ins_and_del</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">is_ins_and_del</span></div>

<div class="viewcode-block" id="VCFRecord.isIndel"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.isIndel">[docs]</a>    <span class="k">def</span> <span class="nf">isIndel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the variant is an insertion or a deletion.</span>

<span class="sd">        :return: True if the variant is an insertion or a deletion.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        :note: If the alternative allele and the reference alle have the same length the variant is considered as a substitution. For example: AA/GC is considered as double substitution and not as double insertion after double deletion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The function &#39;isIndel&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="n">is_indel</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">(),</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">alt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">(),</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">):</span>
            <span class="n">is_indel</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">is_indel</span></div>

<div class="viewcode-block" id="VCFRecord.isInsertion"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.isInsertion">[docs]</a>    <span class="k">def</span> <span class="nf">isInsertion</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the variant is an insertion.</span>

<span class="sd">        :return: True if the variant is an insertion.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        :note: If the alternative allele and the reference alle have the same length the variant is considered as a substitution. For example: AA/GC is considered as double substitution and not as double insertion after double deletion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The function &#39;isInsertion&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="n">is_insertion</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">(),</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">alt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">(),</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">):</span>
            <span class="n">is_insertion</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">is_insertion</span></div>

<div class="viewcode-block" id="VCFRecord.type"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.type">[docs]</a>    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the variant type.</span>

<span class="sd">        :return: &#39;snp&#39; or &#39;indel&#39; or &#39;variation&#39;.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">record_type</span> <span class="o">=</span> <span class="s2">&quot;snp&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isIndel</span><span class="p">():</span>
            <span class="n">record_type</span> <span class="o">=</span> <span class="s2">&quot;indel&quot;</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">record_type</span> <span class="o">=</span> <span class="s2">&quot;variation&quot;</span>
        <span class="k">return</span> <span class="n">record_type</span></div>

<div class="viewcode-block" id="VCFRecord.fastDownstreamed"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.fastDownstreamed">[docs]</a>    <span class="k">def</span> <span class="nf">fastDownstreamed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_handler</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a simplified record (CHROM, POS, ALT and REF) moved to the most downstream postition and standardized.</span>

<span class="sd">        :param seq_handler: File handle to the reference sequences file.</span>
<span class="sd">        :type seq_handler: anacore.sequenceIO.IdxFastaIO</span>
<span class="sd">        :param padding: Size of sliding windows to process reference sequence.</span>
<span class="sd">        :type padding: int</span>
<span class="sd">        :return: The simplified record moved to the most downstream postition and standardized.</span>
<span class="sd">        :rtype: anacore.vcf.VCFRecord</span>

<span class="sd">        .. deprecated::</span>
<span class="sd">            Replaced by :func:`VCFRecord.downstreamed`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">downstreamed</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">,</span> <span class="n">padding</span><span class="p">)</span></div>

<div class="viewcode-block" id="VCFRecord.downstreamed"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.downstreamed">[docs]</a>    <span class="k">def</span> <span class="nf">downstreamed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a simplified record (CHROM, POS, ALT and REF) moved to the most downstream postition and standardized.</span>

<span class="sd">        :param seq_handler: File handle to the reference sequences file.</span>
<span class="sd">        :type seq_handler: anacore.sequenceIO.IdxFastaIO</span>
<span class="sd">        :param buffer_size: Buffer size to read reference sequence file (in nt).</span>
<span class="sd">        :type buffer_size: int</span>
<span class="sd">        :return: The simplified record moved to the most downstream postition and standardized.</span>
<span class="sd">        :rtype: anacore.vcf.VCFRecord</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamed</span><span class="p">(</span><span class="s2">&quot;down&quot;</span><span class="p">,</span> <span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span></div>

<div class="viewcode-block" id="VCFRecord.fastStandardize"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.fastStandardize">[docs]</a>    <span class="k">def</span> <span class="nf">fastStandardize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_handler</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standardize record (move to the most upstream position and remove unecessary nucleotids). This standardization concerns only POS, REF and ALT.</span>

<span class="sd">        :param seq_handler: File handle to the reference sequences file.</span>
<span class="sd">        :type seq_handler: anacore.sequenceIO.IdxFastaIO</span>
<span class="sd">        :param padding: Number of nucleotids to inspect before variant. Upstream movement is limited to this number of nucleotids.</span>
<span class="sd">        :type padding: int</span>

<span class="sd">        .. deprecated::</span>
<span class="sd">            Replaced by :func:`VCFRecord.standardize`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">,</span> <span class="n">padding</span><span class="p">)</span></div>

<div class="viewcode-block" id="VCFRecord.standardize"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.standardize">[docs]</a>    <span class="k">def</span> <span class="nf">standardize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standardize record (move to the most upstream position and remove unecessary nucleotids). This standardization concerns only POS, REF and ALT.</span>

<span class="sd">        :param seq_handler: File handle to the reference sequences file.</span>
<span class="sd">        :type seq_handler: anacore.sequenceIO.IdxFastaIO</span>
<span class="sd">        :param buffer_size: Buffer size to read reference sequence file (in nt).</span>
<span class="sd">        :type buffer_size: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">upstream_rec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upstreamed</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">upstream_rec</span><span class="o">.</span><span class="n">pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">upstream_rec</span><span class="o">.</span><span class="n">ref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">upstream_rec</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="VCFRecord.normalizeSingleAllele"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.normalizeSingleAllele">[docs]</a>    <span class="k">def</span> <span class="nf">normalizeSingleAllele</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace empty allele by the empty_marker and reduce the alternative and reference allele to the minimal string. The position of record is also updated. Example: ATG/A becomes TG/. ; AAGC/ATAC becomes AG/TA.</span>

<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">twoSideTrimming</span><span class="p">(</span><span class="n">record</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Remove identical end and start between reference allele and alternative allele (example: ATGACT/ATCT becomes G/). The end is removed first to manage repeat cases.</span>

<span class="sd">            :param record: The mono-alternative variant.</span>
<span class="sd">            :type record: VCFRecord</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">ref</span>
            <span class="n">alt</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">ref</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">alt</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">ref</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">alt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">alt</span> <span class="o">=</span> <span class="n">alt</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">ref</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">alt</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">alt</span> <span class="o">=</span> <span class="n">alt</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">record</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">record</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span>
            <span class="n">record</span><span class="o">.</span><span class="n">alt</span> <span class="o">=</span> <span class="p">[</span><span class="n">alt</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The function &#39;normalizeSingleAllele&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="c1"># Deletion or insertion with marker</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">():</span>
            <span class="k">pass</span>
        <span class="c1"># Deletion without marker</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]):]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">twoSideTrimming</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">():</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s1">&#39;The deletion &quot;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&quot; at location </span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1"> cannot be normalized.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
        <span class="c1"># Insertion without marker</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">):]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">twoSideTrimming</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">!=</span> <span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">():</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s1">&#39;The insertion &quot;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&quot; at location </span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1"> cannot be normalized.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
        <span class="c1"># Substitution</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">twoSideTrimming</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="VCFRecord.getMostUpstream"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.getMostUpstream">[docs]</a>    <span class="k">def</span> <span class="nf">getMostUpstream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the most upstream variant with same consequence on genomic reference.</span>

<span class="sd">        :param seq_handler: File handle to the reference sequences file.</span>
<span class="sd">        :type seq_handler: anacore.sequenceIO.IdxFastaIO</span>
<span class="sd">        :param buffer_size: Buffer size to read reference sequence file (in nt).</span>
<span class="sd">        :type buffer_size: int</span>
<span class="sd">        :return: The normalized most upstream variant (see normalizeSingleAllele).</span>
<span class="sd">        :rtype: VCFRecord</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The function &#39;getMostUpstream&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span><span class="o">.</span><span class="n">normalizeSingleAllele</span><span class="p">()</span>
        <span class="n">new_record</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span>
        <span class="k">if</span> <span class="n">new_record</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">()</span> <span class="ow">or</span> <span class="n">new_record</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">():</span>  <span class="c1"># normalized indel</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">new_record</span><span class="o">.</span><span class="n">ref</span>
            <span class="n">alt</span> <span class="o">=</span> <span class="n">new_record</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Deletion</span>
            <span class="k">if</span> <span class="n">new_record</span><span class="o">.</span><span class="n">isDeletion</span><span class="p">():</span>
                <span class="n">ref_in_file</span> <span class="o">=</span> <span class="n">seq_handler</span><span class="o">.</span><span class="n">getSub</span><span class="p">(</span><span class="n">new_record</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">new_record</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">new_record</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">ref_in_file</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">!=</span> <span class="n">ref</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                        <span class="s1">&#39;The reference on position </span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1"> does not correspond to &quot;</span><span class="si">{}</span><span class="s1">&quot;.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">new_record</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">new_record</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">ref</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">new_pos</span> <span class="o">=</span> <span class="n">new_record</span><span class="o">.</span><span class="n">pos</span>
                <span class="k">for</span> <span class="n">uc_before_var</span> <span class="ow">in</span> <span class="n">_refDownIter</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">,</span> <span class="n">new_record</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">new_pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">uc_before_var</span> <span class="o">!=</span> <span class="n">ref</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># shift to upstream</span>
                        <span class="n">new_pos</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ref</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">new_record</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">new_pos</span>
                <span class="n">new_record</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span>
            <span class="c1"># Insertion</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_pos</span> <span class="o">=</span> <span class="n">new_record</span><span class="o">.</span><span class="n">pos</span>
                <span class="k">for</span> <span class="n">uc_before_var</span> <span class="ow">in</span> <span class="n">_refDownIter</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">,</span> <span class="n">new_record</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">new_pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">uc_before_var</span> <span class="o">!=</span> <span class="n">alt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># shift to upstream</span>
                        <span class="n">new_pos</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">alt</span> <span class="o">=</span> <span class="n">alt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">alt</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">new_record</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">new_pos</span>
                <span class="n">new_record</span><span class="o">.</span><span class="n">alt</span> <span class="o">=</span> <span class="p">[</span><span class="n">alt</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">new_record</span></div>

<div class="viewcode-block" id="VCFRecord.getMostDownstream"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.getMostDownstream">[docs]</a>    <span class="k">def</span> <span class="nf">getMostDownstream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the most downstream variant with same consequence on genomic reference.</span>

<span class="sd">        :param seq_handler: File handle to the reference sequences file.</span>
<span class="sd">        :type seq_handler: anacore.sequenceIO.IdxFastaIO</span>
<span class="sd">        :param buffer_size: Buffer size to read reference sequence file (in nt).</span>
<span class="sd">        :type buffer_size: int</span>
<span class="sd">        :return: The normalized most downstream variant (see normalizeSingleAllele).</span>
<span class="sd">        :rtype: VCFRecord</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The function &#39;getMostDownstream&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span><span class="o">.</span><span class="n">normalizeSingleAllele</span><span class="p">()</span>
        <span class="n">new_record</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span>
        <span class="k">if</span> <span class="n">new_record</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">()</span> <span class="ow">or</span> <span class="n">new_record</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">():</span>  <span class="c1"># Normalized indel</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">new_record</span><span class="o">.</span><span class="n">ref</span>
            <span class="n">alt</span> <span class="o">=</span> <span class="n">new_record</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Deletion</span>
            <span class="k">if</span> <span class="n">new_record</span><span class="o">.</span><span class="n">isDeletion</span><span class="p">():</span>
                <span class="n">ref_in_file</span> <span class="o">=</span> <span class="n">seq_handler</span><span class="o">.</span><span class="n">getSub</span><span class="p">(</span><span class="n">new_record</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">new_record</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">new_record</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">ref_in_file</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">!=</span> <span class="n">ref</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                        <span class="s1">&#39;The reference on position </span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1"> does not correspond to &quot;</span><span class="si">{}</span><span class="s1">&quot;.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">new_record</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">new_record</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">ref</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">new_pos</span> <span class="o">=</span> <span class="n">new_record</span><span class="o">.</span><span class="n">pos</span>
                <span class="k">for</span> <span class="n">uc_after_var</span> <span class="ow">in</span> <span class="n">_refUpIter</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">,</span> <span class="n">new_record</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">new_pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">),</span> <span class="n">buffer_size</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">uc_after_var</span> <span class="o">!=</span> <span class="n">ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># shift to downstream</span>
                        <span class="n">new_pos</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">new_record</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">new_pos</span>
                <span class="n">new_record</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span>
            <span class="c1"># Insertion</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_pos</span> <span class="o">=</span> <span class="n">new_record</span><span class="o">.</span><span class="n">pos</span>
                <span class="k">for</span> <span class="n">uc_after_var</span> <span class="ow">in</span> <span class="n">_refUpIter</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">,</span> <span class="n">new_record</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">new_pos</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">uc_after_var</span> <span class="o">!=</span> <span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># shift to downstream</span>
                        <span class="n">new_pos</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">alt</span> <span class="o">=</span> <span class="n">alt</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">new_record</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">new_pos</span>
                <span class="n">new_record</span><span class="o">.</span><span class="n">alt</span> <span class="o">=</span> <span class="p">[</span><span class="n">alt</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">new_record</span></div>

<div class="viewcode-block" id="VCFRecord.getPopRefAD"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.getPopRefAD">[docs]</a>    <span class="k">def</span> <span class="nf">getPopRefAD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the reference allele depth for the population (it is composed by all samples).</span>

<span class="sd">        :return: The reference allele population depth.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ref_pop_AD</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;AD&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AD&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># INFO.AD contains ref allele</span>
            <span class="n">ref_pop_AD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AD&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s2">&quot;AF&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="ow">and</span> <span class="s2">&quot;DP&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># INFO.AF contains ref allele and INFO.DP exists</span>
            <span class="n">ref_pop_AD</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;DP&quot;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Must be processed by samples data</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">:</span>  <span class="c1"># Counts are present by samples</span>
                <span class="n">first_spl</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;AD&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_spl</span><span class="p">[</span><span class="s2">&quot;AD&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># AD contains ref allele</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ref_pop_AD</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">spl_name</span><span class="p">,</span> <span class="n">spl_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  <span class="c1"># Sum ref AD for all samples</span>
                            <span class="n">ref_pop_AD</span> <span class="o">+=</span> <span class="n">spl_data</span><span class="p">[</span><span class="s2">&quot;AD&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="n">ref_pop_AD</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">ref_pop_AD</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s2">&quot;AF&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="ow">and</span> <span class="s2">&quot;DP&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_spl</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># AF contains ref allele</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ref_pop_AD</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">spl_name</span><span class="p">,</span> <span class="n">spl_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  <span class="c1"># Sum ref AD for all samples</span>
                            <span class="n">ref_pop_AD</span> <span class="o">+=</span> <span class="n">spl_data</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">spl_data</span><span class="p">[</span><span class="s2">&quot;DP&quot;</span><span class="p">]</span>
                        <span class="n">ref_pop_AD</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ref_pop_AD</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="n">ref_pop_AD</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">ref_pop_AD</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Erroneous when several variants exist on position and are line splitted</span>
            <span class="k">if</span> <span class="s2">&quot;AD&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>  <span class="c1"># INFO.AD does not contain ref</span>
                <span class="n">ref_pop_AD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPopDP</span><span class="p">()</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AD&quot;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s2">&quot;AF&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="ow">and</span> <span class="s2">&quot;DP&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>  <span class="c1"># INFO.AF does not contain ref and INFO.DP exists</span>
                <span class="n">ref_pop_AD</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">]))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;DP&quot;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Must be processed by samples data</span>
                <span class="n">alt_pop_AD</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getPopAltAD</span><span class="p">())</span>
                <span class="n">ref_pop_AD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPopDP</span><span class="p">()</span> <span class="o">-</span> <span class="n">alt_pop_AD</span>
        <span class="k">return</span> <span class="n">ref_pop_AD</span></div>

<div class="viewcode-block" id="VCFRecord.getPopAltAD"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.getPopAltAD">[docs]</a>    <span class="k">def</span> <span class="nf">getPopAltAD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of alternative alleles depths for the population (it is composed by all samples). The reference depth is removed from the result if it exists.</span>

<span class="sd">        :return: The list of alternative alleles depths.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Retrieve AD from self</span>
        <span class="n">AD</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;AD&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>  <span class="c1"># The AD is already processed for the population</span>
            <span class="n">AD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AD&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get population DP</span>
            <span class="n">DP</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">DP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPopDP</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">if</span> <span class="s2">&quot;AF&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="ow">and</span> <span class="n">DP</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># The AD can be processed directly from the population information</span>
                <span class="n">AF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">]]</span>
                <span class="n">AD</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">curr_AF</span> <span class="o">*</span> <span class="n">DP</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">for</span> <span class="n">curr_AF</span> <span class="ow">in</span> <span class="n">AF</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># The AD must be calculated from samples information</span>
                <span class="n">spl_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="s2">&quot;AD&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>  <span class="c1"># Only one sample and it contains AD</span>
                    <span class="n">AD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;AD&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">idx_spl</span><span class="p">,</span> <span class="n">spl_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">idx_spl</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">AD</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_AD</span> <span class="k">for</span> <span class="n">curr_AD</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAltAD</span><span class="p">(</span><span class="n">spl_name</span><span class="p">)]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">for</span> <span class="n">idx_allele</span><span class="p">,</span> <span class="n">curr_AD</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getAltAD</span><span class="p">(</span><span class="n">spl_name</span><span class="p">)):</span>
                                    <span class="n">AD</span><span class="p">[</span><span class="n">idx_allele</span><span class="p">]</span> <span class="o">+=</span> <span class="n">curr_AD</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;The allele depth cannot be retrieved in variant &quot;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&quot;.&#39;</span><span class="p">)</span>
        <span class="c1"># Transform AD to list</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">AD</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">AD</span> <span class="o">=</span> <span class="p">[</span><span class="n">AD</span><span class="p">]</span>
        <span class="c1"># Remove the reference allele depth</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">AD</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">AD</span> <span class="o">=</span> <span class="n">AD</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="c1"># Return</span>
        <span class="k">return</span><span class="p">(</span><span class="n">AD</span><span class="p">)</span></div>

<div class="viewcode-block" id="VCFRecord.getPopRefAF"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.getPopRefAF">[docs]</a>    <span class="k">def</span> <span class="nf">getPopRefAF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the reference allele frequency for the population (it is composed by all samples).</span>

<span class="sd">        :return: The reference allele population frequency.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ref_pop_AF</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;AF&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># INFO.AF contains ref allele</span>
            <span class="n">ref_pop_AF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s2">&quot;AD&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="ow">and</span> <span class="s2">&quot;DP&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AD&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># INFO.AD contains ref allele and INFO.DP exists</span>
            <span class="n">ref_pop_AF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AD&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;DP&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Must be processed by samples data</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">:</span>  <span class="c1"># Counts are present by samples</span>
                <span class="n">first_spl</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;AD&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="ow">and</span> <span class="s2">&quot;DP&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_spl</span><span class="p">[</span><span class="s2">&quot;AD&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># AD contains ref allele</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ref_pop_AD</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">pop_DP</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">spl_name</span><span class="p">,</span> <span class="n">spl_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  <span class="c1"># Sum ref AD for all samples</span>
                            <span class="n">pop_DP</span> <span class="o">+=</span> <span class="n">spl_data</span><span class="p">[</span><span class="s2">&quot;DP&quot;</span><span class="p">]</span>
                            <span class="n">ref_pop_AD</span> <span class="o">+=</span> <span class="n">spl_data</span><span class="p">[</span><span class="s2">&quot;AD&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">ref_pop_AF</span> <span class="o">=</span> <span class="n">ref_pop_AD</span> <span class="o">/</span> <span class="n">pop_DP</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="n">ref_pop_AF</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">ref_pop_AF</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s2">&quot;AF&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="ow">and</span> <span class="s2">&quot;DP&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_spl</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># AF contains ref allele</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ref_pop_AD</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">pop_DP</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">spl_name</span><span class="p">,</span> <span class="n">spl_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  <span class="c1"># Sum ref AF for all samples</span>
                            <span class="n">pop_DP</span> <span class="o">+=</span> <span class="n">spl_data</span><span class="p">[</span><span class="s2">&quot;DP&quot;</span><span class="p">]</span>
                            <span class="n">ref_pop_AD</span> <span class="o">+=</span> <span class="n">spl_data</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">spl_data</span><span class="p">[</span><span class="s2">&quot;DP&quot;</span><span class="p">]</span>
                        <span class="n">ref_pop_AF</span> <span class="o">=</span> <span class="n">ref_pop_AD</span> <span class="o">/</span> <span class="n">pop_DP</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="n">ref_pop_AF</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">ref_pop_AF</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Erroneous when several variants exist on position and are line splitted</span>
            <span class="k">if</span> <span class="s2">&quot;AF&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>  <span class="c1"># INFO.AF does not contain ref</span>
                <span class="n">ref_pop_AF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s2">&quot;AD&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="ow">and</span> <span class="s2">&quot;DP&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>  <span class="c1"># INFO.AD does not contain ref and INFO.DP exists</span>
                <span class="n">ref_pop_AF</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;DP&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AD&quot;</span><span class="p">]))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;DP&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Must be processed by samples data</span>
                <span class="n">alt_pop_AF</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getPopAltAF</span><span class="p">())</span>
                <span class="n">ref_pop_AF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">alt_pop_AF</span>
        <span class="k">return</span> <span class="n">ref_pop_AF</span></div>

<div class="viewcode-block" id="VCFRecord.getPopAltAF"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.getPopAltAF">[docs]</a>    <span class="k">def</span> <span class="nf">getPopAltAF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of alleles frequencies for the population (it is composed by all samples). The reference frequency is removed from the result if it exists.</span>

<span class="sd">        :return: The list of alleles frequencies.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Retrieve AF from self</span>
        <span class="n">AF</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;AF&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>  <span class="c1"># The AF is already processed for the population</span>
            <span class="n">AF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get population DP</span>
            <span class="n">DP</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">DP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPopDP</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">if</span> <span class="s2">&quot;AD&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="ow">and</span> <span class="n">DP</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># The AF can be processed directly from the population information</span>
                <span class="n">AD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AD&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AD&quot;</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AD&quot;</span><span class="p">]]</span>
                <span class="n">AF</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_AD</span> <span class="o">/</span> <span class="n">DP</span> <span class="k">for</span> <span class="n">curr_AD</span> <span class="ow">in</span> <span class="n">AD</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># The AF must be calculated from samples information</span>
                <span class="n">spl_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="s2">&quot;AF&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>  <span class="c1"># Only one sample and it contains AF</span>
                    <span class="n">AF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;AF&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">pop_AD</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="k">for</span> <span class="n">idx_spl</span><span class="p">,</span> <span class="n">spl_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">idx_spl</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">pop_AD</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_AD</span> <span class="k">for</span> <span class="n">curr_AD</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAltAD</span><span class="p">(</span><span class="n">spl_name</span><span class="p">)]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">for</span> <span class="n">idx_allele</span><span class="p">,</span> <span class="n">curr_AD</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getAltAD</span><span class="p">(</span><span class="n">spl_name</span><span class="p">)):</span>
                                    <span class="n">pop_AD</span><span class="p">[</span><span class="n">idx_allele</span><span class="p">]</span> <span class="o">+=</span> <span class="n">curr_AD</span>
                        <span class="k">if</span> <span class="n">DP</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">AF</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">curr_AD</span> <span class="ow">in</span> <span class="n">pop_AD</span><span class="p">]</span>
                            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pop_AD</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;popAD and popDP are not compatible for variant &quot;</span><span class="si">{}</span><span class="s1">&quot;.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">AF</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_AD</span> <span class="o">/</span> <span class="n">DP</span> <span class="k">for</span> <span class="n">curr_AD</span> <span class="ow">in</span> <span class="n">pop_AD</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;The allele frequency cannot be retrieved in variant &quot;</span><span class="si">{}</span><span class="s1">&quot;.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="c1"># Transform AF to list</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">AF</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">AF</span> <span class="o">=</span> <span class="p">[</span><span class="n">AF</span><span class="p">]</span>
        <span class="c1"># Remove the reference allele frequency</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">AF</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">AF</span> <span class="o">=</span> <span class="n">AF</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">AF</span></div>

<div class="viewcode-block" id="VCFRecord.getPopDP"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.getPopDP">[docs]</a>    <span class="k">def</span> <span class="nf">getPopDP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the depth for the population (it is composed by all samples).</span>

<span class="sd">        :return: The depth in population.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">DP</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;DP&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>  <span class="c1"># The DP is already processed for the population</span>
            <span class="n">DP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;DP&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get population AD</span>
            <span class="n">AD</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="s2">&quot;AD&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
                <span class="n">AD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AD&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AD&quot;</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AD&quot;</span><span class="p">]]</span>
            <span class="c1"># Calculate DP</span>
            <span class="k">if</span> <span class="n">AD</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">AD</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># The DP can be processed from INFO&#39;s AD (it contains the depth for all alleles and reference)</span>
                <span class="n">DP</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">AD</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">AD</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s2">&quot;AF&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>  <span class="c1"># The DP can be processed from INFO&#39;s AD and AF</span>
                <span class="n">AF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">]]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">AF</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">AF</span> <span class="o">=</span> <span class="n">AF</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">DP</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">AD</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">AF</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># The DP must be calculated from samples information</span>
                <span class="n">DP</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">getDP</span><span class="p">(</span><span class="n">spl_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">spl_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;The population depth cannot be retrieved in variant &quot;</span><span class="si">{}</span><span class="s1">&quot;.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">DP</span></div>

<div class="viewcode-block" id="VCFRecord.getAD"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.getAD">[docs]</a>    <span class="k">def</span> <span class="nf">getAD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spl_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of alleles depths for the specified sample.</span>

<span class="sd">        :param spl_name: The sample name.</span>
<span class="sd">        :type spl_name: str</span>
<span class="sd">        :return: The list of alleles depths.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">AD</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Retrieve AD from self</span>
        <span class="k">if</span> <span class="s2">&quot;AD&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_name</span><span class="p">]:</span>  <span class="c1"># The AD is already processed for the sample</span>
            <span class="n">AD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_name</span><span class="p">][</span><span class="s2">&quot;AD&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">spl_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">and</span> <span class="s2">&quot;AD&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>  <span class="c1"># Only one sample and AD is already processed for population</span>
            <span class="n">AD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AD&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># AD must be calculated</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">AF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAF</span><span class="p">(</span><span class="n">spl_name</span><span class="p">)</span>
                <span class="n">DP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDP</span><span class="p">(</span><span class="n">spl_name</span><span class="p">)</span>
                <span class="n">AD</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">curr_AF</span> <span class="o">*</span> <span class="n">DP</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">for</span> <span class="n">curr_AF</span> <span class="ow">in</span> <span class="n">AF</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;The alternative alleles depths cannot be retrieved in variant &quot;</span><span class="si">{}</span><span class="s1">&quot;.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="c1"># Transform AD to list</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">AD</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">AD</span> <span class="o">=</span> <span class="p">[</span><span class="n">AD</span><span class="p">]</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">AD</span></div>

<div class="viewcode-block" id="VCFRecord.getAltAD"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.getAltAD">[docs]</a>    <span class="k">def</span> <span class="nf">getAltAD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spl_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of alternative alleles depths for the specified sample. The reference depth is removed from the result if it exists.</span>

<span class="sd">        :param spl_name: The sample name.</span>
<span class="sd">        :type spl_name: str</span>
<span class="sd">        :return: The list of alternative alleles depths.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">AD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAD</span><span class="p">(</span><span class="n">spl_name</span><span class="p">)</span>
        <span class="c1"># Remove the reference allele depth</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">AD</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">AD</span> <span class="o">=</span> <span class="n">AD</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">AD</span></div>

<div class="viewcode-block" id="VCFRecord.getAFBySample"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.getAFBySample">[docs]</a>    <span class="k">def</span> <span class="nf">getAFBySample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">missing_replacement</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of alleles frequencies by sample name. The reference frequency is removed from the result if it exists.</span>

<span class="sd">        :param missing_replacement: Value used to replace missing AF.</span>
<span class="sd">        :type missing_replacement: float</span>
<span class="sd">        :return: The list of alleles frequencies by sample name.</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">AF</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">curr_spl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">:</span>
            <span class="n">AF</span><span class="p">[</span><span class="n">curr_spl</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">curr_AF</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAF</span><span class="p">(</span><span class="n">curr_spl</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">curr_AF</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">missing_replacement</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">curr_AF</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">missing_replacement</span><span class="p">)</span>
                <span class="n">AF</span><span class="p">[</span><span class="n">curr_spl</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_AF</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">AF</span></div>

<div class="viewcode-block" id="VCFRecord.getAF"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.getAF">[docs]</a>    <span class="k">def</span> <span class="nf">getAF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spl_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of alleles frequencies for the specified sample.</span>

<span class="sd">        :param spl_name: The sample name.</span>
<span class="sd">        :type spl_name: str</span>
<span class="sd">        :return: The list of alleles frequencies.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Retrieve AF from self</span>
        <span class="n">AF</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;AF&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_name</span><span class="p">]:</span>  <span class="c1"># The AF is already processed for the sample</span>
            <span class="n">AF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_name</span><span class="p">][</span><span class="s2">&quot;AF&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get sample AD</span>
            <span class="n">AD</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="s2">&quot;AD&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_name</span><span class="p">]:</span>
                <span class="n">AD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_name</span><span class="p">][</span><span class="s2">&quot;AD&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_name</span><span class="p">][</span><span class="s2">&quot;AD&quot;</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_name</span><span class="p">][</span><span class="s2">&quot;AD&quot;</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">AD</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">AD</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># The AF can be processed from sample&#39;s AD (it contains the depth for alleles and reference)</span>
                <span class="n">DP</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">AD</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">DP</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">AF</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">curr_AD</span> <span class="ow">in</span> <span class="n">AD</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">AF</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_AD</span> <span class="o">/</span> <span class="n">DP</span> <span class="k">for</span> <span class="n">curr_AD</span> <span class="ow">in</span> <span class="n">AD</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Get sample DP</span>
                <span class="n">DP</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">DP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDP</span><span class="p">(</span><span class="n">spl_name</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">if</span> <span class="n">AD</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">DP</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># The AF can be processed from sample&#39;s AD and DP</span>
                    <span class="k">if</span> <span class="n">DP</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">AF</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">curr_AD</span> <span class="ow">in</span> <span class="n">AD</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">AF</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_AD</span> <span class="o">/</span> <span class="n">DP</span> <span class="k">for</span> <span class="n">curr_AD</span> <span class="ow">in</span> <span class="n">AD</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">spl_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">and</span> <span class="s2">&quot;AF&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>  <span class="c1"># Only one sample and AF is already processed for population</span>
                    <span class="n">AF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">]</span>
                <span class="c1"># elif len(self.samples) == 1 and spl_name in self.samples and &quot;AD&quot; in self.info and DP is not None: # Only one sample and AF must be processed for population</span>
                <span class="c1">#     AD = self.info[&quot;AD&quot;]</span>
                <span class="c1">#     AF = [curr_AD/float(DP) for curr_AD in AD]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;The allele frequency cannot be retrieved in variant &quot;</span><span class="si">{}</span><span class="s1">&quot;.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="c1"># Transform AF to list</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">AF</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">AF</span> <span class="o">=</span> <span class="p">[</span><span class="n">AF</span><span class="p">]</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">AF</span></div>

<div class="viewcode-block" id="VCFRecord.getAltAF"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.getAltAF">[docs]</a>    <span class="k">def</span> <span class="nf">getAltAF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spl_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of alternative alleles frequencies for the specified sample. The reference frequency is removed from the result if it exists.</span>

<span class="sd">        :param spl_name: The sample name.</span>
<span class="sd">        :type spl_name: str</span>
<span class="sd">        :return: The list of alternative alleles frequencies.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">AF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAF</span><span class="p">(</span><span class="n">spl_name</span><span class="p">)</span>
        <span class="c1"># Remove the reference allele frequency</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">AF</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">AF</span> <span class="o">=</span> <span class="n">AF</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">AF</span></div>

<div class="viewcode-block" id="VCFRecord.getDP"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.getDP">[docs]</a>    <span class="k">def</span> <span class="nf">getDP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spl_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the depth for the specified sample.</span>

<span class="sd">        :param spl_name: The sample name.</span>
<span class="sd">        :type spl_name: str</span>
<span class="sd">        :return: The depth.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">DP</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;DP&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_name</span><span class="p">]:</span>  <span class="c1"># The DP is already processed for the sample</span>
            <span class="n">DP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_name</span><span class="p">][</span><span class="s2">&quot;DP&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">spl_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">and</span> <span class="s2">&quot;DP&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>  <span class="c1"># Only one sample and DP is already processed for population</span>
            <span class="n">DP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;DP&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s2">&quot;AD&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_name</span><span class="p">]:</span>  <span class="c1"># DP can be calculated</span>
            <span class="n">AD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_name</span><span class="p">][</span><span class="s2">&quot;AD&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_name</span><span class="p">][</span><span class="s2">&quot;AD&quot;</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_name</span><span class="p">][</span><span class="s2">&quot;AD&quot;</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">AD</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Sample contains AD for all alleles and reference</span>
                <span class="n">DP</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">AD</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s2">&quot;AF&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_name</span><span class="p">]:</span>  <span class="c1"># Sample contains AD for all alleles and AF</span>
                <span class="n">AF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_name</span><span class="p">][</span><span class="s2">&quot;AF&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_name</span><span class="p">][</span><span class="s2">&quot;AF&quot;</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_name</span><span class="p">][</span><span class="s2">&quot;AF&quot;</span><span class="p">]]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">AF</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">AF</span> <span class="o">=</span> <span class="n">AF</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">DP</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">AD</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">AF</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># AD does not contain reference AD and AF is missing to calculate DP</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;The depth cannot be retrieved in variant &quot;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&quot;.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># AD is missing to calculate DP</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;The depth cannot be retrieved in variant &quot;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&quot;.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DP</span></div>

<div class="viewcode-block" id="VCFRecord.streamed"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.streamed">[docs]</a>    <span class="k">def</span> <span class="nf">streamed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream_direction</span><span class="p">,</span> <span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a simplified record (CHROM, POS, ALT and REF) moved to the most upstream or downstream postition and standardized.</span>

<span class="sd">        :param seq_handler: File handle to the reference sequences file.</span>
<span class="sd">        :type seq_handler: anacore.sequenceIO.IdxFastaIO</span>
<span class="sd">        :param stream_direction: Stream direction: &quot;up&quot; or &quot;down&quot;.</span>
<span class="sd">        :type stream_direction: str</span>
<span class="sd">        :param buffer_size: Buffer size to read reference sequence file (in nt).</span>
<span class="sd">        :type buffer_size: int</span>
<span class="sd">        :return: The simplified record moved to the most upstream or downstream postition and standardized.</span>
<span class="sd">        :rtype: anacore.vcf.VCFRecord</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;The function &quot;streamed&quot; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="n">new_rec</span> <span class="o">=</span> <span class="n">VCFRecord</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span> <span class="p">[</span><span class="n">elt</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_rec</span><span class="o">.</span><span class="n">_normalized</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span><span class="p">)</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">(),</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">alt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">(),</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stream_direction</span> <span class="o">==</span> <span class="s2">&quot;up&quot;</span><span class="p">:</span>
                <span class="n">new_rec</span> <span class="o">=</span> <span class="n">new_rec</span><span class="o">.</span><span class="n">getMostUpstream</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_rec</span> <span class="o">=</span> <span class="n">new_rec</span><span class="o">.</span><span class="n">getMostDownstream</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt</span><span class="p">):</span>
                <span class="c1"># For simple insertions and deletions in which either the REF or</span>
                <span class="c1"># one of the ALT alleles would otherwise be null/empty, the REF</span>
                <span class="c1"># and ALT Strings must include the base before the variant</span>
                <span class="c1"># (which must be reflected in the POS field), unless the variant</span>
                <span class="c1"># occurs at position 1 on the contig in which case it must</span>
                <span class="c1"># include the base after the variant</span>
                <span class="k">if</span> <span class="n">new_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Add next nt</span>
                    <span class="k">if</span> <span class="n">new_rec</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">():</span>  <span class="c1"># Insertion</span>
                        <span class="n">first_nt</span> <span class="o">=</span> <span class="n">seq_handler</span><span class="o">.</span><span class="n">getSub</span><span class="p">(</span><span class="n">new_rec</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
                        <span class="n">new_rec</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">first_nt</span>
                        <span class="n">new_rec</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_rec</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">first_nt</span>
                    <span class="k">elif</span> <span class="n">new_rec</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">():</span>  <span class="c1"># Deletion</span>
                        <span class="n">next_nt</span> <span class="o">=</span> <span class="n">seq_handler</span><span class="o">.</span><span class="n">getSub</span><span class="p">(</span><span class="n">new_rec</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
                        <span class="n">new_rec</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">new_rec</span><span class="o">.</span><span class="n">ref</span> <span class="o">+</span> <span class="n">next_nt</span>
                        <span class="n">new_rec</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_nt</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Add previous nt</span>
                    <span class="k">if</span> <span class="n">new_rec</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">():</span>  <span class="c1"># Insertion</span>
                        <span class="n">prev_nt</span> <span class="o">=</span> <span class="n">seq_handler</span><span class="o">.</span><span class="n">getSub</span><span class="p">(</span><span class="n">new_rec</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">new_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">new_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
                        <span class="n">new_rec</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">prev_nt</span>
                        <span class="n">new_rec</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_nt</span> <span class="o">+</span> <span class="n">new_rec</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">new_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">new_rec</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">VCFRecord</span><span class="o">.</span><span class="n">getEmptyAlleleMarker</span><span class="p">():</span>  <span class="c1"># Deletion</span>
                        <span class="n">prev_nt</span> <span class="o">=</span> <span class="n">seq_handler</span><span class="o">.</span><span class="n">getSub</span><span class="p">(</span><span class="n">new_rec</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">new_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">new_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
                        <span class="n">new_rec</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">prev_nt</span> <span class="o">+</span> <span class="n">new_rec</span><span class="o">.</span><span class="n">ref</span>
                        <span class="n">new_rec</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_nt</span>
                        <span class="n">new_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">new_rec</span></div>

<div class="viewcode-block" id="VCFRecord.upstreamed"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFRecord.upstreamed">[docs]</a>    <span class="k">def</span> <span class="nf">upstreamed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a simplified record (CHROM, POS, ALT and REF) moved to the most upstream postition and standardized.</span>

<span class="sd">        :param seq_handler: File handle to the reference sequences file.</span>
<span class="sd">        :type seq_handler: anacore.sequenceIO.IdxFastaIO</span>
<span class="sd">        :param buffer_size: Buffer size to read reference sequence file (in nt).</span>
<span class="sd">        :type buffer_size: int</span>
<span class="sd">        :return: The simplified record moved to the most upstream postition and standardized.</span>
<span class="sd">        :rtype: anacore.vcf.VCFRecord</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamed</span><span class="p">(</span><span class="s2">&quot;up&quot;</span><span class="p">,</span> <span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="VCFSymbAltRecord"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFSymbAltRecord">[docs]</a><span class="k">class</span> <span class="nc">VCFSymbAltRecord</span><span class="p">(</span><span class="n">VCFRecord</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to manage a variant record with symbolic alternative like &lt;DUP&gt;, &lt;DEL&gt;, etc.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign value to the attribute.</span>

<span class="sd">        :param name: The attribute name.</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param value: The value to be assigned to the attribute.</span>
<span class="sd">        :type value: *</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;alt&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">alt</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">alt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Alternative allele </span><span class="si">{}</span><span class="s2"> is not a symbolic allele.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">alt</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">alt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;BND&quot;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;BND are not managed by </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="VCFSymbAltRecord.containsIndel"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFSymbAltRecord.containsIndel">[docs]</a>    <span class="k">def</span> <span class="nf">containsIndel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the variant contains an allele corresponding to an insertion or a deletion.</span>

<span class="sd">        :return: True if the variant contains an allele corresponding to an insertion or a deletion.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :note: If the alternative allele and the reference alle have the same length the variant is considered as a substitution. For example: AA/GC is considered as double substitution and not as double insertion after double deletion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Method &#39;containsIndel&#39; is not implemented for </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span></div>

<div class="viewcode-block" id="VCFSymbAltRecord.downstreamed"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFSymbAltRecord.downstreamed">[docs]</a>    <span class="k">def</span> <span class="nf">downstreamed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">convert_dup</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return record moved to the most downstream postition.</span>

<span class="sd">        :param seq_handler: File handle to the reference sequences file.</span>
<span class="sd">        :type seq_handler: anacore.sequenceIO.IdxFastaIO</span>
<span class="sd">        :param buffer_size: Buffer size to read reference sequence file (in nt).</span>
<span class="sd">        :type buffer_size: int</span>
<span class="sd">        :param convert_dup: If True, DUP are converted to INS to move on most downstream.</span>
<span class="sd">        :type convert_dup: bool</span>
<span class="sd">        :return: Record moved to the most downstream postition.</span>
<span class="sd">        :rtype: anacore.vcf.VCFSymbAltRecord</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamed</span><span class="p">(</span><span class="s2">&quot;down&quot;</span><span class="p">,</span> <span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">,</span> <span class="n">convert_dup</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return end position of the variant (1-based).</span>

<span class="sd">        :return: End position of the variant (1-based). This position correspond to the last reference nt implicated in variant. For example, in DUP, the position correspond to last duplicated nt on reference.</span>
<span class="sd">        :rtype: int | None</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The attribute &#39;end&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;END&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;END&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;INS&quot;</span><span class="p">):</span>  <span class="c1"># INS</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="k">elif</span> <span class="s2">&quot;SVLEN&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>  <span class="c1"># CNV or DEL or DUP or INV</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sv_len</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">end</span>

<div class="viewcode-block" id="VCFSymbAltRecord.getMostDownstream"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFSymbAltRecord.getMostDownstream">[docs]</a>    <span class="k">def</span> <span class="nf">getMostDownstream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">convert_dup</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the most downstream variant with same consequence on genomic reference.</span>

<span class="sd">        :param seq_handler: File handle to the reference sequences file.</span>
<span class="sd">        :type seq_handler: anacore.sequenceIO.IdxFastaIO</span>
<span class="sd">        :param buffer_size: Buffer size to read reference sequence file (in nt).</span>
<span class="sd">        :type buffer_size: int</span>
<span class="sd">        :return: The most downstream variant.</span>
<span class="sd">        :param convert_dup: If True, DUP are converted to INS to move on most downstream.</span>
<span class="sd">        :type convert_dup: bool</span>
<span class="sd">        :rtype: VCFRecord</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">downstreamed_rec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;IMPRECISE&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
            <span class="n">downstreamed_rec</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;CIPOS&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
            <span class="n">downstreamed_rec</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">cipos_up</span><span class="p">,</span> <span class="n">cipos_down</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;CIPOS&quot;</span><span class="p">]</span>  <span class="c1"># 2 numbers in releases prior to VCF4.4 and 2 * alt_nb after</span>
            <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="n">cipos_down</span>
            <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;CIPOS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cipos_up</span> <span class="o">-</span> <span class="n">cipos_down</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">!=</span> <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">pos</span><span class="p">:</span>  <span class="c1"># Moved</span>
                <span class="k">if</span> <span class="n">convert_dup</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;DUP&quot;</span><span class="p">):</span>  <span class="c1"># DUP and authorized to convert to INS</span>
                    <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">alt</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&lt;INS&gt;&quot;</span><span class="p">]</span>
                    <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sv_len</span><span class="p">)</span>
                    <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;CIPOS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;CIPOS&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sv_len</span><span class="p">),</span> <span class="mi">0</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="s2">&quot;END&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
                        <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;END&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">pos</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># All others</span>
                    <span class="k">if</span> <span class="s2">&quot;END&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
                        <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;END&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cipos_down</span>
                <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">seq_handler</span><span class="o">.</span><span class="n">getSub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">alt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;INS&quot;</span><span class="p">):</span>  <span class="c1"># Sequence of insertion is unknown</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s1">&#39;Symbolic insertion </span><span class="si">{}</span><span class="s1"> cannot be convert to litteral: sequence is unknown.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">downstreamed_rec</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">alt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;DUP&quot;</span><span class="p">):</span>
                <span class="n">litteral_rec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">litteralized</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">)</span>
                <span class="n">litteral_downstreamed_rec</span> <span class="o">=</span> <span class="n">litteral_rec</span><span class="o">.</span><span class="n">downstreamed</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>
                <span class="n">downstreamed_rec</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">!=</span> <span class="n">litteral_downstreamed_rec</span><span class="o">.</span><span class="n">pos</span><span class="p">:</span>  <span class="c1"># DUP has been moved</span>
                    <span class="k">if</span> <span class="n">convert_dup</span><span class="p">:</span>
                        <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">litteral_downstreamed_rec</span><span class="o">.</span><span class="n">pos</span>
                        <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">litteral_downstreamed_rec</span><span class="o">.</span><span class="n">ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">alt</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&lt;INS&gt;&quot;</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">litteral_downstreamed_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sv_len</span><span class="p">)</span>
                        <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">seq_handler</span><span class="o">.</span><span class="n">getSub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
                <span class="k">if</span> <span class="s2">&quot;END&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
                    <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;END&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sv_len</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">alt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;DEL&quot;</span><span class="p">):</span>
                <span class="n">litteral_rec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">litteralized</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">)</span>
                <span class="n">litteral_downstreamed_rec</span> <span class="o">=</span> <span class="n">litteral_rec</span><span class="o">.</span><span class="n">downstreamed</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>
                <span class="n">downstreamed_rec</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">litteral_downstreamed_rec</span><span class="o">.</span><span class="n">pos</span>
                <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">litteral_downstreamed_rec</span><span class="o">.</span><span class="n">ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;END&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
                    <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;END&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sv_len</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">alt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;CNV&quot;</span><span class="p">):</span>  <span class="c1"># CNV is DUP or TANDEM or DEL</span>
                <span class="n">sv_len</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sv_len</span><span class="p">)</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="n">seq_handler</span><span class="o">.</span><span class="n">getSub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="n">sv_len</span><span class="p">)</span>
                <span class="n">alt</span> <span class="o">=</span> <span class="n">ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">litteral_rec</span> <span class="o">=</span> <span class="n">VCFRecord</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="p">[</span><span class="n">alt</span><span class="p">])</span>  <span class="c1"># DEL and DUP have the same downstream behaviour</span>
                <span class="n">litteral_downstreamed_rec</span> <span class="o">=</span> <span class="n">litteral_rec</span><span class="o">.</span><span class="n">downstreamed</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>
                <span class="n">downstreamed_rec</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">litteral_downstreamed_rec</span><span class="o">.</span><span class="n">pos</span>
                <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">litteral_downstreamed_rec</span><span class="o">.</span><span class="n">ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;END&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
                    <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;END&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">downstreamed_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
            <span class="k">elif</span> <span class="n">alt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;INV&quot;</span><span class="p">):</span>  <span class="c1"># INV cannot be moved</span>
                <span class="n">downstreamed_rec</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unknown symbolic type &quot;</span><span class="si">{}</span><span class="s1">&quot; in </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">alt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">downstreamed_rec</span></div>

<div class="viewcode-block" id="VCFSymbAltRecord.getMostUpstream"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFSymbAltRecord.getMostUpstream">[docs]</a>    <span class="k">def</span> <span class="nf">getMostUpstream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the most upstream variant with same consequence on genomic reference.</span>

<span class="sd">        :param seq_handler: File handle to the reference sequences file.</span>
<span class="sd">        :type seq_handler: anacore.sequenceIO.IdxFastaIO</span>
<span class="sd">        :param buffer_size: Buffer size to read reference sequence file (in nt).</span>
<span class="sd">        :type buffer_size: int</span>
<span class="sd">        :return: The most upstream variant.</span>
<span class="sd">        :rtype: TestVCFSymbAltRecord</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The function &#39;getMostUpstream&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="n">upstream_rec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;IMPRECISE&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
            <span class="n">upstream_rec</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;CIPOS&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
            <span class="n">upstream_rec</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">cipos_up</span><span class="p">,</span> <span class="n">cipos_down</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;CIPOS&quot;</span><span class="p">]</span>  <span class="c1"># 2 numbers in releases prior to VCF4.4 and 2 * alt_nb after</span>
            <span class="k">if</span> <span class="n">cipos_up</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">upstream_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">upstream_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="n">cipos_up</span>
                <span class="n">upstream_rec</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;CIPOS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="n">cipos_down</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">cipos_up</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="s2">&quot;END&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
                    <span class="n">upstream_rec</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;END&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cipos_up</span>
                <span class="n">upstream_rec</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">seq_handler</span><span class="o">.</span><span class="n">getSub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">upstream_rec</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">upstream_rec</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">alt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;INS&quot;</span><span class="p">):</span>  <span class="c1"># Sequence of insertion is unknown</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s1">&#39;Symbolic insertion </span><span class="si">{}</span><span class="s1"> cannot be convert to litteral: sequence is unknown.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">upstream_rec</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">alt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;CNV&quot;</span><span class="p">):</span>  <span class="c1"># CNV is DUP or TANDEM or DEL</span>
                <span class="n">sv_len</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sv_len</span><span class="p">)</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="n">seq_handler</span><span class="o">.</span><span class="n">getSub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="n">sv_len</span><span class="p">)</span>
                <span class="n">alt</span> <span class="o">=</span> <span class="n">ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">litteral_rec</span> <span class="o">=</span> <span class="n">VCFRecord</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="p">[</span><span class="n">alt</span><span class="p">])</span>  <span class="c1"># DEL and DUP have the same upstream behaviour</span>
                <span class="n">litteral_upstream_rec</span> <span class="o">=</span> <span class="n">litteral_rec</span><span class="o">.</span><span class="n">upstreamed</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>
                <span class="n">upstream_rec</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">upstream_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">litteral_upstream_rec</span><span class="o">.</span><span class="n">pos</span>
                <span class="n">upstream_rec</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">litteral_upstream_rec</span><span class="o">.</span><span class="n">ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;END&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
                    <span class="n">upstream_rec</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;END&quot;</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">upstream_rec</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">alt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;INV&quot;</span><span class="p">):</span>  <span class="c1"># INV cannot be moved</span>
                <span class="n">upstream_rec</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">litteral_rec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">litteralized</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">)</span>
                <span class="n">litteral_upstream_rec</span> <span class="o">=</span> <span class="n">litteral_rec</span><span class="o">.</span><span class="n">upstreamed</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>
                <span class="n">upstream_rec</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">upstream_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">litteral_upstream_rec</span><span class="o">.</span><span class="n">pos</span>
                <span class="n">upstream_rec</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">litteral_upstream_rec</span><span class="o">.</span><span class="n">ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;END&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">alt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;DEL&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">alt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;DUP&quot;</span><span class="p">):</span>
                        <span class="n">upstream_rec</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;END&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">upstream_rec</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sv_len</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unknown symbolic type &quot;</span><span class="si">{}</span><span class="s1">&quot; in </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">alt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">upstream_rec</span></div>

<div class="viewcode-block" id="VCFSymbAltRecord.getName"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFSymbAltRecord.getName">[docs]</a>    <span class="k">def</span> <span class="nf">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an unique name to identified the variant.</span>

<span class="sd">        :return: The variant name.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        :warnings: This name can be not uniq for two insertions on same position and with same length.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">[</span><span class="si">{}</span><span class="s2">]=</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sv_len</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sv_len</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span>
            <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="VCFSymbAltRecord.isDeletion"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFSymbAltRecord.isDeletion">[docs]</a>    <span class="k">def</span> <span class="nf">isDeletion</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the variant is a deletion.</span>

<span class="sd">        :return: True if the variant is a deletion.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The function &#39;isDeletion&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="n">is_deletion</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># DUP or INS or INV</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;DEL&quot;</span><span class="p">):</span>  <span class="c1"># DEL</span>
            <span class="n">is_deletion</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;CNV&quot;</span><span class="p">):</span>  <span class="c1"># CNV</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;CNV can be deletion or insertion on variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">is_deletion</span></div>

<div class="viewcode-block" id="VCFSymbAltRecord.isIndel"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFSymbAltRecord.isIndel">[docs]</a>    <span class="k">def</span> <span class="nf">isIndel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the variant is an insertion or a deletion.</span>

<span class="sd">        :return: True if the variant is an insertion or a deletion.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The function &#39;isIndel&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;CNV&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">isDeletion</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">isInsertion</span><span class="p">()</span>  <span class="c1"># CNV may be both deletion and duplication</span></div>

<div class="viewcode-block" id="VCFSymbAltRecord.isInsAndDel"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFSymbAltRecord.isInsAndDel">[docs]</a>    <span class="k">def</span> <span class="nf">isInsAndDel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the variant is an insertion and also a deletion.</span>

<span class="sd">        :return: True if the variant is an insertion and also a deletion.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The function &#39;isInsAndDel&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;INV&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VCFSymbAltRecord.isInsertion"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFSymbAltRecord.isInsertion">[docs]</a>    <span class="k">def</span> <span class="nf">isInsertion</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the variant is an insertion.</span>

<span class="sd">        :return: True if the variant is an insertion.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The function &#39;isInsertion&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="n">is_insertion</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># DEL or INV</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;DUP&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;INS&quot;</span><span class="p">):</span>  <span class="c1"># DUP or INS</span>
            <span class="n">is_insertion</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;CNV&quot;</span><span class="p">):</span>  <span class="c1"># CNV</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;CNV can be deletion or insertion on variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">is_insertion</span></div>

<div class="viewcode-block" id="VCFSymbAltRecord.isInversion"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFSymbAltRecord.isInversion">[docs]</a>    <span class="k">def</span> <span class="nf">isInversion</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the variant is a deletion.</span>

<span class="sd">        :return: True if the variant is a deletion.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The function &#39;isInversion&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;INV&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VCFSymbAltRecord.litteralized"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFSymbAltRecord.litteralized">[docs]</a>    <span class="k">def</span> <span class="nf">litteralized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_handler</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return simplified (only chrom, id, ref and alt) litteral (replace symbole by sequence) version of symbolic record.</span>

<span class="sd">        :param seq_handler: File handle to the reference sequences file.</span>
<span class="sd">        :type seq_handler: anacore.sequenceIO.IdxFastaIO</span>
<span class="sd">        :return: Simplified (only chrom, id, ref and alt) litteral (replace symbole by sequence) version of symbolic record.</span>
<span class="sd">        :rtype: VCFRecord</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The function &#39;litteralized&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="n">self_alt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">self_alt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;INS&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s1">&#39;Symbolic insertion &quot;</span><span class="si">{}</span><span class="s1">&quot; cannot be convert to litteral: sequence is unknown.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;IMPRECISE&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s1">&#39;IMPRECISE symbolic variant &quot;</span><span class="si">{}</span><span class="s1">&quot; cannot be convert to litteral: real position is unknown.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">self_alt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;DEL&quot;</span><span class="p">):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">seq_handler</span><span class="o">.</span><span class="n">getSub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sv_len</span><span class="p">))</span>
            <span class="n">alt</span> <span class="o">=</span> <span class="n">ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">self_alt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;INV&quot;</span><span class="p">):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">seq_handler</span><span class="o">.</span><span class="n">getSub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sv_len</span><span class="p">))</span>
            <span class="n">alt</span> <span class="o">=</span> <span class="n">ref</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">self_alt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;DUP&quot;</span><span class="p">):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span>
            <span class="n">alt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">+</span> <span class="n">seq_handler</span><span class="o">.</span><span class="n">getSub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sv_len</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">self_alt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;CNV&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s1">&#39;Symbolic CNV &quot;</span><span class="si">{}</span><span class="s1">&quot; cannot be convert to litteral: CNV can be DUP or DEL depending on sample.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">VCFRecord</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="p">[</span><span class="n">alt</span><span class="p">])</span></div>

<div class="viewcode-block" id="VCFSymbAltRecord.normalizeSingleAllele"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFSymbAltRecord.normalizeSingleAllele">[docs]</a>    <span class="k">def</span> <span class="nf">normalizeSingleAllele</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Method &#39;normalizeSingleAllele&#39; is not implemented for </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span></div>

<div class="viewcode-block" id="VCFSymbAltRecord.refEnd"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFSymbAltRecord.refEnd">[docs]</a>    <span class="k">def</span> <span class="nf">refEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the last position on reference affected by the alternative allele (1-based).</span>

<span class="sd">        :return: The last position on reference affected by the alternative allele (1-based). For an insertion between two nucleotids the value will be: first nucleotids pos + 0.5.</span>
<span class="sd">        :rtype: float | None</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The function &#39;refEnd&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;CNV&quot;</span><span class="p">):</span>  <span class="c1"># CNV</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The method &#39;refEnd&#39; cannot be used on CNV: it can be deletion or insertion.&quot;</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span>  <span class="c1"># DEL or INV</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isInsertion</span><span class="p">():</span>  <span class="c1"># DUP or INS</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="mf">0.5</span>
        <span class="k">return</span> <span class="n">end</span></div>

<div class="viewcode-block" id="VCFSymbAltRecord.refStart"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFSymbAltRecord.refStart">[docs]</a>    <span class="k">def</span> <span class="nf">refStart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first position on reference affected by the alternative allele (1-based).</span>

<span class="sd">        :return: The first position on reference affected by the alternative allele (1-based). For an insertion between two nucleotids the value will be: first nucleotids pos + 0.5.</span>
<span class="sd">        :rtype: float | None</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The function &#39;refStart&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;CNV&quot;</span><span class="p">):</span>  <span class="c1"># CNV</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The method &#39;refStart&#39; cannot be used on CNV: it can be deletion or insertion.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isInsertion</span><span class="p">():</span>  <span class="c1"># DUP or INS</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="mf">0.5</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># DEL or INV</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">start</span></div>

<div class="viewcode-block" id="VCFSymbAltRecord.standardize"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFSymbAltRecord.standardize">[docs]</a>    <span class="k">def</span> <span class="nf">standardize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standardize record (move to the most upstream position). This standardization concerns only POS, REF, ALT, INFO.CIPOS and INFO.END.</span>

<span class="sd">        :param seq_handler: File handle to the reference sequences file.</span>
<span class="sd">        :type seq_handler: anacore.sequenceIO.IdxFastaIO</span>
<span class="sd">        :param buffer_size: Buffer size to read reference sequence file (in nt).</span>
<span class="sd">        :type buffer_size: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upstreamed</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">std</span><span class="o">.</span><span class="n">pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">std</span><span class="o">.</span><span class="n">ref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alt</span> <span class="o">=</span> <span class="n">std</span><span class="o">.</span><span class="n">alt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">std</span><span class="o">.</span><span class="n">info</span></div>

<div class="viewcode-block" id="VCFSymbAltRecord.streamed"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFSymbAltRecord.streamed">[docs]</a>    <span class="k">def</span> <span class="nf">streamed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream_direction</span><span class="p">,</span> <span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">down_convert_dup</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return record moved to the most upstream or downstream postition and standardized.</span>

<span class="sd">        :param seq_handler: File handle to the reference sequences file.</span>
<span class="sd">        :type seq_handler: anacore.sequenceIO.IdxFastaIO</span>
<span class="sd">        :param stream_direction: Stream direction: &quot;up&quot; or &quot;down&quot;.</span>
<span class="sd">        :type stream_direction: str</span>
<span class="sd">        :param buffer_size: Buffer size to read reference sequence file (in nt).</span>
<span class="sd">        :type buffer_size: int</span>
<span class="sd">        :param down_convert_dup: For downstream direction, if True, DUP are converted to INS to move on most downstream.</span>
<span class="sd">        :type down_convert_dup: bool</span>
<span class="sd">        :return: The record moved to the most upstream or downstream postition and standardized.</span>
<span class="sd">        :rtype: anacore.vcf.VCFRecord</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stream_direction</span> <span class="o">==</span> <span class="s2">&quot;up&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMostUpstream</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMostDownstream</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">,</span> <span class="n">down_convert_dup</span><span class="p">)</span></div>
        <span class="c1"># if &quot;IMPRECISE&quot; not in self.info and &quot;CIPOS&quot; not in self.info:</span>
        <span class="c1">#     downstream = self.downstreamed(seq_handler, buffer_size)</span>
        <span class="c1">#     if downstream.pos != self.pos:  # can be move to downstream</span>
        <span class="c1">#         self.info[&quot;CIPOS&quot;] = [0, downstream.pos - self.pos]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sv_len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return difference in length between REF and ALT alleles.</span>

<span class="sd">        :return: Difference in length between REF and ALT alleles. Longer ALT alleles (e.g. insertions) have positive values, shorter ALT alleles (e.g. deletions) have negative values and CNV are unsigned.</span>
<span class="sd">        :rtype: int | None</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The attribute &#39;sv_len&#39; cannot be used on multi-allelic variant </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">VCFRecord</span><span class="o">.</span><span class="n">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="n">sv_len</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;SVLEN&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
            <span class="n">sv_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;SVLEN&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sv_len</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">sv_len</span> <span class="o">=</span> <span class="n">sv_len</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;CNV&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isDeletion</span><span class="p">()</span> <span class="ow">and</span> <span class="n">sv_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Since VCF 4.4 SVLEN is absolute value: &gt;0 can be ins or del</span>
                    <span class="n">sv_len</span> <span class="o">=</span> <span class="n">sv_len</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="s2">&quot;END&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
            <span class="n">sv_len</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>  <span class="c1"># CNV or DUP or INV</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;CNV&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isDeletion</span><span class="p">():</span>  <span class="c1"># DEL</span>
                    <span class="n">sv_len</span> <span class="o">=</span> <span class="n">sv_len</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;INS&quot;</span><span class="p">):</span>  <span class="c1"># INS length cannot be known from END</span>
                    <span class="n">sv_len</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">sv_len</span>

<div class="viewcode-block" id="VCFSymbAltRecord.type"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFSymbAltRecord.type">[docs]</a>    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the variant type.</span>

<span class="sd">        :return: &#39;indel&#39; or &#39;inv&#39;.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        :warnings: This method can only be used on record with only one alternative allele.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">record_type</span> <span class="o">=</span> <span class="s2">&quot;indel&quot;</span>  <span class="c1"># DEL or DUP or CNV or INS</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;INV&quot;</span><span class="p">):</span>  <span class="c1"># INV</span>
            <span class="n">record_type</span> <span class="o">=</span> <span class="s2">&quot;inv&quot;</span>
        <span class="k">return</span> <span class="n">record_type</span></div>

<div class="viewcode-block" id="VCFSymbAltRecord.upstreamed"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFSymbAltRecord.upstreamed">[docs]</a>    <span class="k">def</span> <span class="nf">upstreamed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return record moved to the most upstream postition.</span>

<span class="sd">        :param seq_handler: File handle to the reference sequences file.</span>
<span class="sd">        :type seq_handler: anacore.sequenceIO.IdxFastaIO</span>
<span class="sd">        :param buffer_size: Buffer size to read reference sequence file (in nt).</span>
<span class="sd">        :type buffer_size: int</span>
<span class="sd">        :return: Record moved to the most upstream postition.</span>
<span class="sd">        :rtype: anacore.vcf.VCFSymbAltRecord</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamed</span><span class="p">(</span><span class="s2">&quot;up&quot;</span><span class="p">,</span> <span class="n">seq_handler</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="VCFIO"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFIO">[docs]</a><span class="k">class</span> <span class="nc">VCFIO</span><span class="p">(</span><span class="n">AbstractFile</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Manage VCF file.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return instance of VCFIO.</span>

<span class="sd">        :param filepath: The filepath.</span>
<span class="sd">        :type filepath: str</span>
<span class="sd">        :param mode: Mode to open the file (&#39;r&#39;, &#39;w&#39;, &#39;a&#39;, &#39;i&#39;). The mode &#39;i&#39; allow to open file in indexed mode to fetch by region (tabix).</span>
<span class="sd">        :type mode: str</span>
<span class="sd">        :return: The new instance</span>
<span class="sd">        :rtype: anacore.vcf.VCFIO</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">standard_mode</span> <span class="o">=</span> <span class="n">mode</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s2">&quot;i&quot;</span> <span class="k">else</span> <span class="s2">&quot;r&quot;</span>
        <span class="n">AbstractFile</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="n">standard_mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># {&quot;q10&quot;: &lt;HeaderFilterAttr&gt;}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># {&quot;IDREP&quot;: &lt;HeaderInfoAttr&gt;, &quot;AD&quot;: &lt;HeaderInfoAttr&gt;}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># {&quot;GT&quot;: &lt;HeaderFormatAttr&gt;, &quot;AD&quot;: &lt;HeaderFormatAttr&gt;}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># {&quot;splA&quot;: &lt;HeaderSampleAttr&gt;, &quot;splB&quot;: &lt;HeaderSampleAttr&gt;}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_header</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># [&quot;##source=myImputationProgramV3.1&quot;, &quot;##phasing=partial&quot;]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span>  <span class="c1"># Load header in append mode</span>
            <span class="k">with</span> <span class="n">VCFIO</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tmp_reader</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">copyHeader</span><span class="p">(</span><span class="n">tmp_reader</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">}:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parseHeader</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">TabixFile</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

<div class="viewcode-block" id="VCFIO.getSub"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFIO.getSub">[docs]</a>    <span class="k">def</span> <span class="nf">getSub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">chr</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return generator on records overlapping the specified region.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            This method can only be used with an instance of anacore.VCFIO opened</span>
<span class="sd">            with mode &quot;i&quot;.</span>

<span class="sd">        :param chr: Chromosome name of the selected region.</span>
<span class="sd">        :type chr: str</span>
<span class="sd">        :param start: Start of the selected region (1-based).</span>
<span class="sd">        :type start: int</span>
<span class="sd">        :param end: End of the selected region (1-based).</span>
<span class="sd">        :type end: int</span>
<span class="sd">        :return: Records overlappind the specified region.</span>
<span class="sd">        :rtype: generator for anacore.vcf.VCFRecord</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The file </span><span class="si">{}</span><span class="s2"> must be open in mode &#39;i&#39; to use </span><span class="si">{}</span><span class="s2">.getSub() on it.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_handle</span><span class="p">,</span> <span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="n">iterator</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">iterator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="nb">chr</span><span class="p">,</span> <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
            <span class="n">missing_region</span> <span class="o">=</span> <span class="s2">&quot;could not create iterator for region &#39;</span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">-</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">chr</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">missing_region</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">error</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_line</span> <span class="o">=</span> <span class="n">row</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parseLine</span><span class="p">()</span></div>

<div class="viewcode-block" id="VCFIO.isRecordLine"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFIO.isRecordLine">[docs]</a>    <span class="k">def</span> <span class="nf">isRecordLine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the line corresponds to a record (it is not a comment or an header line).</span>

<span class="sd">        :param line: The evaluated line.</span>
<span class="sd">        :type line: str</span>
<span class="sd">        :return: True if the line corresponds to a record.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_record</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">):</span>
            <span class="n">is_record</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">is_record</span></div>

    <span class="k">def</span> <span class="nf">_parseHeader</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse VCF header to set info, format and samples attributes.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_line_nb</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_handle</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
        <span class="n">is_header</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">):</span>
            <span class="n">is_header</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">is_header</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parseHeaderLine</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_line</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#CHROM&quot;</span><span class="p">):</span>  <span class="c1"># Last header line</span>
                <span class="n">is_header</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_line_nb</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_handle</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_parseHeaderLine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse one VCF header line to update info, filter, format or samples attributes.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;##INFO&quot;</span><span class="p">):</span>
            <span class="n">curr_attr</span> <span class="o">=</span> <span class="n">getHeaderAttr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_line</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">curr_attr</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_attr</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;##FILTER&quot;</span><span class="p">):</span>
            <span class="n">curr_attr</span> <span class="o">=</span> <span class="n">getHeaderAttr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_line</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">[</span><span class="n">curr_attr</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_attr</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;##FORMAT&quot;</span><span class="p">):</span>
            <span class="n">curr_attr</span> <span class="o">=</span> <span class="n">getHeaderAttr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_line</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">[</span><span class="n">curr_attr</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_attr</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;##SAMPLE&quot;</span><span class="p">):</span>
            <span class="n">curr_attr</span> <span class="o">=</span> <span class="n">getHeaderAttr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_line</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_info</span><span class="p">[</span><span class="n">curr_attr</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_attr</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#CHROM</span><span class="se">\t</span><span class="s2">POS&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">spl</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">spl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)[</span><span class="mi">9</span><span class="p">:]]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;##fileformat=&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extra_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_line</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_parseLine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a structured record from the VCF current line.</span>

<span class="sd">        :return: The variant described by the current line.</span>
<span class="sd">        :rtype: VCFRecord</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">elt</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)]</span>
        <span class="n">variation</span> <span class="o">=</span> <span class="n">VCFRecord</span><span class="p">()</span>
        <span class="n">variation</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">variation</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">variation</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">variation</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">variation</span><span class="o">.</span><span class="n">alt</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
        <span class="n">variation</span><span class="o">.</span><span class="n">qual</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="k">if</span> <span class="n">fields</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;.&quot;</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">fields</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;.&quot;</span> <span class="ow">and</span> <span class="n">fields</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">variation</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">:</span>
            <span class="c1"># Field INFO</span>
            <span class="k">if</span> <span class="n">fields</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
                <span class="n">info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">tag_and_value</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">):</span>
                    <span class="k">if</span> <span class="s2">&quot;=&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tag_and_value</span><span class="p">:</span>  <span class="c1"># The field is a flag (self.info[tag]._number == 0)</span>
                        <span class="n">info</span><span class="p">[</span><span class="n">tag_and_value</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tag</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">tag_and_value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="o">.</span><span class="n">_number</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># The field contains an unique value</span>
                            <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>  <span class="c1"># Exclude key None value</span>
                                <span class="n">info</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="o">.</span><span class="n">_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;String&quot;</span><span class="p">:</span>
                                    <span class="n">info</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">decodeInfoValue</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="n">tag</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>  <span class="c1"># The field contains a list (self.info[tag]._number is None or self.info[tag]._number &gt; 1)</span>
                            <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                                <span class="n">info</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>
                                <span class="k">pass</span>  <span class="c1"># Exclude key with None list</span>
                            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;String&quot;</span><span class="p">:</span>
                                <span class="n">info</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">decodeInfoValue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="o">.</span><span class="n">_type</span><span class="p">(</span><span class="n">list_elt</span><span class="p">))</span> <span class="k">for</span> <span class="n">list_elt</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">info</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="o">.</span><span class="n">_type</span><span class="p">(</span><span class="n">list_elt</span><span class="p">)</span> <span class="k">for</span> <span class="n">list_elt</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)]</span>
                <span class="n">variation</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">9</span><span class="p">:</span>
                <span class="c1"># Field FORMAT</span>
                <span class="n">variation</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">fields</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;.&quot;</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="c1"># Fields samples</span>
                <span class="n">data_by_spl</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">spl_idx</span><span class="p">,</span> <span class="n">spl_cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">9</span><span class="p">:]):</span>
                    <span class="n">spl_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">variation</span><span class="o">.</span><span class="n">format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Samples cannot have any data if format is None</span>
                        <span class="k">for</span> <span class="n">field_idx</span><span class="p">,</span> <span class="n">field_data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spl_cell</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)):</span>
                            <span class="n">field_id</span> <span class="o">=</span> <span class="n">variation</span><span class="o">.</span><span class="n">format</span><span class="p">[</span><span class="n">field_idx</span><span class="p">]</span>
                            <span class="n">field_format</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">[</span><span class="n">field_id</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">field_format</span><span class="o">.</span><span class="n">_number</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">field_format</span><span class="o">.</span><span class="n">_number</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Value is list</span>
                                <span class="k">if</span> <span class="n">field_data</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>  <span class="c1"># Value is None in VCF</span>
                                    <span class="k">if</span> <span class="n">field_format</span><span class="o">.</span><span class="n">number</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">]:</span>
                                        <span class="n">spl_data</span><span class="p">[</span><span class="n">field_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">alt</span> <span class="ow">in</span> <span class="n">variation</span><span class="o">.</span><span class="n">alt</span><span class="p">]</span>
                                        <span class="k">if</span> <span class="n">field_format</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
                                            <span class="n">spl_data</span><span class="p">[</span><span class="n">field_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                                    <span class="k">elif</span> <span class="n">field_format</span><span class="o">.</span><span class="n">_number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                        <span class="n">spl_data</span><span class="p">[</span><span class="n">field_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">field_format</span><span class="o">.</span><span class="n">_number</span><span class="p">)]</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">spl_data</span><span class="p">[</span><span class="n">field_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
                                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Value is not None in VCF</span>
                                    <span class="n">spl_data</span><span class="p">[</span><span class="n">field_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                                    <span class="k">for</span> <span class="n">list_elt</span> <span class="ow">in</span> <span class="n">field_data</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">):</span>
                                        <span class="k">if</span> <span class="n">list_elt</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>
                                            <span class="n">spl_data</span><span class="p">[</span><span class="n">field_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                                        <span class="k">else</span><span class="p">:</span>
                                            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">[</span><span class="n">field_id</span><span class="p">]</span><span class="o">.</span><span class="n">_type</span><span class="p">(</span><span class="n">list_elt</span><span class="p">)</span>
                                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">[</span><span class="n">field_id</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;String&quot;</span><span class="p">:</span>
                                                <span class="n">value</span> <span class="o">=</span> <span class="n">decodeInfoValue</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                                            <span class="n">spl_data</span><span class="p">[</span><span class="n">field_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="n">field_format</span><span class="o">.</span><span class="n">_number</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Value is not a list</span>
                                <span class="k">if</span> <span class="n">field_data</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>
                                    <span class="n">spl_data</span><span class="p">[</span><span class="n">field_id</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">spl_data</span><span class="p">[</span><span class="n">field_id</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">[</span><span class="n">field_id</span><span class="p">]</span><span class="o">.</span><span class="n">_type</span><span class="p">(</span><span class="n">field_data</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">[</span><span class="n">field_id</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;String&quot;</span><span class="p">:</span>
                                        <span class="n">spl_data</span><span class="p">[</span><span class="n">field_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">decodeInfoValue</span><span class="p">(</span><span class="n">spl_data</span><span class="p">[</span><span class="n">field_id</span><span class="p">])</span>
                            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Number == 0</span>
                                <span class="n">spl_data</span><span class="p">[</span><span class="n">field_id</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">data_by_spl</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_idx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">spl_data</span>
                <span class="n">variation</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">data_by_spl</span>

        <span class="c1"># Convert symbolic</span>
        <span class="k">if</span> <span class="n">variation</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">):</span>
            <span class="n">variation</span> <span class="o">=</span> <span class="n">VCFSymbAltRecord</span><span class="p">(</span>
                <span class="n">variation</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">variation</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">variation</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">variation</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span>
                <span class="n">variation</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span> <span class="n">variation</span><span class="o">.</span><span class="n">qual</span><span class="p">,</span> <span class="n">variation</span><span class="o">.</span><span class="n">filter</span><span class="p">,</span>
                <span class="n">variation</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">variation</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">variation</span><span class="o">.</span><span class="n">samples</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">variation</span>

<div class="viewcode-block" id="VCFIO.write"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFIO.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write variant record in VCF.</span>

<span class="sd">        :param record: The variant record.</span>
<span class="sd">        :type record: VCFRecord</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">recToVCFLine</span><span class="p">(</span><span class="n">record</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VCFIO.recToVCFLine"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFIO.recToVCFLine">[docs]</a>    <span class="k">def</span> <span class="nf">recToVCFLine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the record in VCF format.</span>

<span class="sd">        :param record: The record to process.</span>
<span class="sd">        :type record: VCFRecord</span>
<span class="sd">        :return: The VCF line.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Standard columns</span>
        <span class="n">line</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
            <span class="n">record</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">pos</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;.&quot;</span> <span class="k">if</span> <span class="n">record</span><span class="o">.</span><span class="n">id</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">record</span><span class="o">.</span><span class="n">id</span><span class="p">),</span>
            <span class="n">record</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span>
            <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">alt</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;.&quot;</span> <span class="k">if</span> <span class="n">record</span><span class="o">.</span><span class="n">qual</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">qual</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;.&quot;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">filter</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">filter</span><span class="p">))</span>
        <span class="p">])</span>
        <span class="c1"># Info</span>
        <span class="k">if</span> <span class="n">record</span><span class="o">.</span><span class="n">info</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">info</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">info_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">info</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">_number</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">_number</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># The info may cointain a list of values</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">encodeInfoValue</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">elt</span><span class="p">))</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">record</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>
                    <span class="n">info_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># The info contains a flag or a uniq value</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Flag</span>
                        <span class="n">info_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">encodeInfoValue</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
                        <span class="n">info_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span> <span class="o">+</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">line</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">info_fields</span><span class="p">)</span>
        <span class="c1"># Format</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># the VCF contains a column format</span>
            <span class="k">if</span> <span class="n">record</span><span class="o">.</span><span class="n">format</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">record</span><span class="o">.</span><span class="n">format</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>  <span class="c1"># Current record does not contain information on samples</span>
                <span class="c1"># Format column</span>
                <span class="n">line</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">.&quot;</span>
                <span class="c1"># Samples columns</span>
                <span class="k">for</span> <span class="n">spl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">:</span>
                    <span class="n">line</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">.&quot;</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Current record contains information on samples</span>
                <span class="c1"># Format column</span>
                <span class="n">line</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>
                <span class="c1"># Samples columns</span>
                <span class="k">if</span> <span class="n">record</span><span class="o">.</span><span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">spl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">:</span>
                        <span class="n">line</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;.&quot;</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">record</span><span class="o">.</span><span class="n">format</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">spl_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">:</span>
                        <span class="n">record_spl</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl_name</span><span class="p">]</span>
                        <span class="n">spl_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">record</span><span class="o">.</span><span class="n">format</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">record_spl</span><span class="p">:</span>
                                <span class="n">spl_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">_number</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">_number</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># The info may cointain a list of values</span>
                                    <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                                    <span class="k">for</span> <span class="n">current_val</span> <span class="ow">in</span> <span class="n">record_spl</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                                        <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">encodeInfoValue</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">current_val</span><span class="p">))</span> <span class="k">if</span> <span class="n">current_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span>
                                        <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                                    <span class="n">spl_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
                                <span class="k">else</span><span class="p">:</span>  <span class="c1"># The format contains a uniq value</span>
                                    <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">encodeInfoValue</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">record_spl</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span> <span class="k">if</span> <span class="n">record_spl</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span>
                                    <span class="n">spl_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                        <span class="n">line</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">spl_fields</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">line</span></div>

<div class="viewcode-block" id="VCFIO.copyHeader"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFIO.copyHeader">[docs]</a>    <span class="k">def</span> <span class="nf">copyHeader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy header fields from the specified VCF.</span>

<span class="sd">        :param model: The VCF source.</span>
<span class="sd">        :type model: VCFIO</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">filter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_info</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">sample_info</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_header</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">extra_header</span><span class="p">)</span></div>

<div class="viewcode-block" id="VCFIO.writeHeader"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.VCFIO.writeHeader">[docs]</a>    <span class="k">def</span> <span class="nf">writeHeader</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write VCF header.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;##fileformat=VCFv4.3</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">curr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra_header</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">curr</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;##INFO=</span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">tag</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;##FILTER=</span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">[</span><span class="n">tag</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;##FORMAT=</span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">[</span><span class="n">tag</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">spl</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_info</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;##SAMPLE=</span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_info</span><span class="p">[</span><span class="n">spl</span><span class="p">]))</span>
        <span class="n">last_header_line</span> <span class="o">=</span> <span class="s2">&quot;#CHROM</span><span class="se">\t</span><span class="s2">POS</span><span class="se">\t</span><span class="s2">ID</span><span class="se">\t</span><span class="s2">REF</span><span class="se">\t</span><span class="s2">ALT</span><span class="se">\t</span><span class="s2">QUAL</span><span class="se">\t</span><span class="s2">FILTER</span><span class="se">\t</span><span class="s2">INFO&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">last_header_line</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">FORMAT</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">spl</span> <span class="k">for</span> <span class="n">spl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">last_header_line</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="getAlleleRecord"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.getAlleleRecord">[docs]</a><span class="k">def</span> <span class="nf">getAlleleRecord</span><span class="p">(</span><span class="n">FH_vcf</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="n">idx_alt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the record corresponding to the specified allele in variant.</span>

<span class="sd">    :param FH_vcf: Handler on record source file.</span>
<span class="sd">    :type FH_vcf: anacore.vcf.VCFIO</span>
<span class="sd">    :param record: The variant record.</span>
<span class="sd">    :type record: anacore.vcf.VCFRecord</span>
<span class="sd">    :param idx_alt: The index of the allele in alt attribute.</span>
<span class="sd">    :type idx_alt: int</span>
<span class="sd">    :return: The record corresponding to the specified allele in variant.</span>
<span class="sd">    :rtype: anacore.vcf.VCFRecord</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_class</span> <span class="o">=</span> <span class="n">VCFRecord</span>
    <span class="k">if</span> <span class="n">record</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="n">idx_alt</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">):</span>
        <span class="n">new_class</span> <span class="o">=</span> <span class="n">VCFSymbAltRecord</span>
    <span class="n">new_record</span> <span class="o">=</span> <span class="n">new_class</span><span class="p">(</span>
        <span class="n">region</span><span class="o">=</span><span class="n">record</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
        <span class="n">position</span><span class="o">=</span><span class="n">record</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
        <span class="n">knownSNPId</span><span class="o">=</span><span class="n">record</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
        <span class="n">refAllele</span><span class="o">=</span><span class="n">record</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span>  <span class="c1">########################### pb transfo</span>
        <span class="n">altAlleles</span><span class="o">=</span><span class="p">[</span><span class="n">record</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="n">idx_alt</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()],</span>  <span class="c1">########################### pb transfo</span>
        <span class="n">qual</span><span class="o">=</span><span class="n">record</span><span class="o">.</span><span class="n">qual</span><span class="p">,</span>
        <span class="n">pFilter</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">filter</span><span class="p">),</span>
        <span class="n">pFormat</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="c1"># Info</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">info</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">FH_vcf</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="s2">&quot;A&quot;</span><span class="p">:</span>
            <span class="n">new_record</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">record</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_alt</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">FH_vcf</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
            <span class="n">new_record</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">record</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">record</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx_alt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">FH_vcf</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">_number</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">FH_vcf</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">_number</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_record</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">elt</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">record</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_record</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="c1"># Samples</span>
    <span class="k">for</span> <span class="n">spl</span> <span class="ow">in</span> <span class="n">record</span><span class="o">.</span><span class="n">samples</span><span class="p">:</span>
        <span class="n">new_record</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">record</span><span class="o">.</span><span class="n">format</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">record</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">FH_vcf</span><span class="o">.</span><span class="n">format</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="s2">&quot;A&quot;</span><span class="p">:</span>
                    <span class="n">new_record</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">record</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">idx_alt</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">FH_vcf</span><span class="o">.</span><span class="n">format</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
                    <span class="n">new_record</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">record</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">record</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">idx_alt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">FH_vcf</span><span class="o">.</span><span class="n">format</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">_number</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">FH_vcf</span><span class="o">.</span><span class="n">format</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">_number</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">new_record</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">elt</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">record</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl</span><span class="p">][</span><span class="n">key</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_record</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">spl</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">new_record</span></div>


<div class="viewcode-block" id="getFreqMatrix"><a class="viewcode-back" href="../../anacore.html#anacore.vcf.getFreqMatrix">[docs]</a><span class="k">def</span> <span class="nf">getFreqMatrix</span><span class="p">(</span><span class="n">vcf_path</span><span class="p">,</span> <span class="n">missing_replacement</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">accept_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a 2D matrix representing variants frequencies by sample.</span>

<span class="sd">    :param vcf_path: The pass to the VCF processed.</span>
<span class="sd">    :type vcf_path: str</span>
<span class="sd">    :param missing_replacement: The value used to replace missing alleles frequencies (example: np.nan).</span>
<span class="sd">    :type missing_replacement: *</span>
<span class="sd">    :param accept_missing: If false and a missing AF is found an exception is raised. If true the missing AF are replaced by missing_replacement.</span>
<span class="sd">    :type accept_missing: bool</span>
<span class="sd">    :return: The list of samples, the list of variants names and the 2D matrix of alleles frequencies.</span>
<span class="sd">    :rtype: list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">variants</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">AF_matrix</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">VCFIO</span><span class="p">(</span><span class="n">vcf_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">FH_vcf</span><span class="p">:</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">FH_vcf</span><span class="o">.</span><span class="n">samples</span>
        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">FH_vcf</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">alt_idx</span><span class="p">,</span> <span class="n">curr_alt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">alt</span><span class="p">):</span>  <span class="c1"># For each alternative allele in variant</span>
                <span class="n">record_allele</span> <span class="o">=</span> <span class="n">getAlleleRecord</span><span class="p">(</span><span class="n">FH_vcf</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="n">alt_idx</span><span class="p">)</span>
                <span class="n">variants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">record_allele</span><span class="o">.</span><span class="n">getName</span><span class="p">())</span>
                <span class="n">row_array</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">curr_spl</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">:</span>
                    <span class="n">AF</span> <span class="o">=</span> <span class="n">record_allele</span><span class="o">.</span><span class="n">getAF</span><span class="p">(</span><span class="n">curr_spl</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">AF</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">AF</span> <span class="o">=</span> <span class="n">missing_replacement</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">accept_missing</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The AF is missing for variant </span><span class="si">{}</span><span class="s2"> in sample </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">curr_spl</span><span class="p">,</span> <span class="n">record_allele</span><span class="o">.</span><span class="n">getName</span><span class="p">()))</span>
                    <span class="n">row_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AF</span><span class="p">)</span>
                <span class="n">AF_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_array</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">samples</span><span class="p">,</span> <span class="n">variants</span><span class="p">,</span> <span class="n">AF_matrix</span></div>


<span class="k">def</span> <span class="nf">_refDownIter</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a generator to read nt by nt the uppercased reference sequence from pos to downstream.</span>

<span class="sd">    :param seq_handler: File handle to the sequences file.</span>
<span class="sd">    :type seq_handler: anacore.sequenceIO.IdxFastaIO</span>
<span class="sd">    :param chrom: Name of chromosome/contig to read.</span>
<span class="sd">    :type chrom: str</span>
<span class="sd">    :param pos: Start position on chromosome.</span>
<span class="sd">    :type pos: int</span>
<span class="sd">    :param buffer_size: Buffer size for sequence file reading (in nt). Iterator return nt by nt but to optimise read in file the buffer is larger.</span>
<span class="sd">    :type buffer_size: int</span>
<span class="sd">    :return: Generator to read nt by nt the uppercased reference sequence from pos to downstream.</span>
<span class="sd">    :rtype: generator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">while</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">uc_ref</span> <span class="o">=</span> <span class="n">seq_handler</span><span class="o">.</span><span class="n">getSub</span><span class="p">(</span>
            <span class="n">chrom</span><span class="p">,</span>
            <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">buffer_size</span><span class="p">),</span>
            <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">uc_ref</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">yield</span> <span class="n">char</span>
        <span class="n">pos</span> <span class="o">-=</span> <span class="p">(</span><span class="n">buffer_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_refUpIter</span><span class="p">(</span><span class="n">seq_handler</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a generator to read nt by nt the uppercased reference sequence from pos to upstream.</span>

<span class="sd">    :param seq_handler: File handle to the sequences file.</span>
<span class="sd">    :type seq_handler: anacore.sequenceIO.IdxFastaIO</span>
<span class="sd">    :param chrom: Name of chromosome/contig to read.</span>
<span class="sd">    :type chrom: str</span>
<span class="sd">    :param pos: Start position on chromosome.</span>
<span class="sd">    :type pos: int</span>
<span class="sd">    :param buffer_size: Buffer size for sequence file reading (in nt). Iterator return nt by nt but to optimise read in file the buffer is larger.</span>
<span class="sd">    :type buffer_size: int</span>
<span class="sd">    :return: Generator to read nt by nt the uppercased reference sequence from pos to upstream.</span>
<span class="sd">    :rtype: generator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chrom_size</span> <span class="o">=</span> <span class="n">seq_handler</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">chrom_size</span><span class="p">:</span>
        <span class="n">uc_ref</span> <span class="o">=</span> <span class="n">seq_handler</span><span class="o">.</span><span class="n">getSub</span><span class="p">(</span>
            <span class="n">chrom</span><span class="p">,</span>
            <span class="nb">min</span><span class="p">(</span><span class="n">chrom_size</span><span class="p">,</span> <span class="n">pos</span><span class="p">),</span>
            <span class="nb">min</span><span class="p">(</span><span class="n">chrom_size</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">buffer_size</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">uc_ref</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">char</span>
        <span class="n">pos</span> <span class="o">+=</span> <span class="n">buffer_size</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, Frédéric Escudié.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>