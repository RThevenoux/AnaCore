

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>anacore.msi.base &mdash; AnaCore  documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/anacore.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> AnaCore
          

          
            
            <img src="../../../_static/anacore_logo_40deg.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../anacore.html">AnaCore package</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">AnaCore</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>anacore.msi.base</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for anacore.msi.base</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Classes and functions for manipulating/processing MSI information (status, data, ...).&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Frederic Escudie&#39;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s1">&#39;Copyright (C) 2018 IUCT-O&#39;</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s1">&#39;GNU General Public License&#39;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s1">&#39;2.0.0&#39;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s1">&#39;escudie.frederic@iuct-oncopole.fr&#39;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s1">&#39;prod&#39;</span>

<span class="kn">from</span> <span class="nn">anacore.msi.locus</span> <span class="kn">import</span> <span class="n">LocusRes</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<div class="viewcode-block" id="toDict"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.toDict">[docs]</a><span class="k">def</span> <span class="nf">toDict</span><span class="p">(</span><span class="n">msi_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retuns a dictionary representing the object. This method is used in json.dump in argument named &quot;default&quot; for recursively convert an object to json.</span>

<span class="sd">    :param msi_object: The object to convert.</span>
<span class="sd">    :type msi_object: a class of anacore.msi library</span>
<span class="sd">    :return: The dictionary representing the object.</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">msi_object</span><span class="o">.</span><span class="vm">__dict__</span></div>


<div class="viewcode-block" id="Status"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.Status">[docs]</a><span class="k">class</span> <span class="nc">Status</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Status for samples (MSISplRes) and loci (LocusRes) in anacore.msi library.&quot;&quot;&quot;</span>

    <span class="n">stable</span> <span class="o">=</span> <span class="s2">&quot;MSS&quot;</span>
    <span class="n">unstable</span> <span class="o">=</span> <span class="s2">&quot;MSI&quot;</span>
    <span class="n">undetermined</span> <span class="o">=</span> <span class="s2">&quot;Undetermined&quot;</span>  <span class="c1"># Cannot be determined</span>
    <span class="n">none</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Not evaluated</span>

<div class="viewcode-block" id="Status.authorizedValues"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.Status.authorizedValues">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">authorizedValues</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return authorized values for stability status.</span>

<span class="sd">        :return: Authorized for stability status.</span>
<span class="sd">        :rtype: set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">attr_value</span> <span class="k">for</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">attr_value</span> <span class="ow">in</span> <span class="n">Status</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">attr_name</span> <span class="o">!=</span> <span class="s2">&quot;authorizedValues&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">attr_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)}</span></div></div>


<div class="viewcode-block" id="LocusClassifier"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusClassifier">[docs]</a><span class="k">class</span> <span class="nc">LocusClassifier</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classifier for locus using MSISample objects.</span>

<span class="sd">    Synopsis:</span>
<span class="sd">        clf = LocusClassifier(locus_id, method_name, classifier)</span>
<span class="sd">        clf.fit(train_dataset)</span>
<span class="sd">        clf.predict(test_dataset)</span>
<span class="sd">        clf.predict_proba(test_dataset)</span>


<span class="sd">        clf = LocusClassifier(locus_id, method_name, classifier)</span>
<span class="sd">        clf.fit(train_dataset)</span>
<span class="sd">        clf.set_status(test_dataset)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locus_id</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">classifier</span><span class="p">,</span> <span class="n">model_method_name</span><span class="o">=</span><span class="s2">&quot;model&quot;</span><span class="p">,</span> <span class="n">data_method_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of LocusClassifier.</span>

<span class="sd">        :param locus_id: The ID (format: chr:start-end with start 0-based) of the loci targeted in analysis.</span>
<span class="sd">        :type locus_id: str</span>
<span class="sd">        :param method_name: By method name the analyses of sample status.</span>
<span class="sd">        :type method_name: dict</span>
<span class="sd">        :param classifier: The classifier used to predict status.</span>
<span class="sd">        :type classifier: A sklearn classifier object</span>
<span class="sd">        :param model_method_name: The name of the method used in models loci to store expected status and lengths distributions.</span>
<span class="sd">        :type model_method_name: str</span>
<span class="sd">        :param data_method_name: The data used for the prediction are extracted from the results of this method. By default the selected method is the same of the classifier method_name.</span>
<span class="sd">        :type data_method_name: str</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: LocusClassifier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">classifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_method_name</span> <span class="o">=</span> <span class="n">method_name</span> <span class="k">if</span> <span class="n">data_method_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">data_method_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locus_id</span> <span class="o">=</span> <span class="n">locus_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method_name</span> <span class="o">=</span> <span class="n">method_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_method_name</span> <span class="o">=</span> <span class="n">model_method_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_len</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># This value is used to uniformise lengths distributions in the comparison</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_len</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># This value is used to uniformise lengths distributions in the comparison</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train_dataset</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># The MSISample provided for fitting. These samples are filtered before fit (see _usable_train_dataset)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_usable_train_dataset</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># The MSISample containing status information for the locus</span>

    <span class="k">def</span> <span class="nf">_get_min_max_len</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the minimum and maximum length for the locus in the dataset.</span>

<span class="sd">        :param dataset: The list of MSISample.</span>
<span class="sd">        :type dataset: list</span>
<span class="sd">        :param method: The lengths distribution of the loci are extracted from the results of this method.</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :return: The list of MSISample.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">min_len</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">curr_spl</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
            <span class="n">locus_res</span> <span class="o">=</span> <span class="n">curr_spl</span><span class="o">.</span><span class="n">loci</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">locus_id</span><span class="p">]</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
            <span class="n">min_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_len</span><span class="p">,</span> <span class="n">locus_res</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;lengths&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">getMinLength</span><span class="p">())</span>
            <span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_len</span><span class="p">,</span> <span class="n">locus_res</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;lengths&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">getMaxLength</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">min_len</span><span class="p">,</span> <span class="n">max_len</span>

    <span class="k">def</span> <span class="nf">_set_min_max_len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the minimum and maximum length for the locus in the dataset (train + test).&quot;&quot;&quot;</span>
        <span class="n">train_min</span><span class="p">,</span> <span class="n">train_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_min_max_len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_usable_train_dataset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_method_name</span><span class="p">)</span>
        <span class="n">test_min</span><span class="p">,</span> <span class="n">test_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_min_max_len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_method_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">train_min</span><span class="p">,</span> <span class="n">test_min</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">train_max</span><span class="p">,</span> <span class="n">test_max</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return uniformised lengths distribution from the dataset.</span>

<span class="sd">        :param dataset: The list of MSISample.</span>
<span class="sd">        :type dataset: list</span>
<span class="sd">        :param method: The lengths distribution of the loci are extracted from the results of this method.</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :return: The uniformised lengths distribution. Rows are samples, columns are lengths and values are percentages of counts in the sample.</span>
<span class="sd">        :rtype: np.matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prct_matrix</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># rows are samples, columns are lengths and values are percentages of counts in the sample.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_len</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_len</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_min_max_len</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">curr_spl</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
            <span class="n">locus_res</span> <span class="o">=</span> <span class="n">curr_spl</span><span class="o">.</span><span class="n">loci</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">locus_id</span><span class="p">]</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
            <span class="n">prct_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">locus_res</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;lengths&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">getDensePrct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_min_len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_len</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">prct_matrix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_test_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return uniformised lengths distribution for samples in test dataset.</span>

<span class="sd">        :return: The uniformised lengths distribution. Rows are samples, columns are lengths and values are percentages of counts in the sample.</span>
<span class="sd">        :rtype: np.matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_method_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_train_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return uniformised lengths distribution for samples in usable train dataset.</span>

<span class="sd">        :return: The uniformised lengths distribution. Rows are samples, columns are lengths and values are percentages of counts in the sample.</span>
<span class="sd">        :rtype: np.matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_usable_train_dataset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_method_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_train_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of labels for samples in usable train dataset.</span>

<span class="sd">        :return: The list of labels for samples in usable train dataset.</span>
<span class="sd">        :rtype: np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">curr_spl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_usable_train_dataset</span><span class="p">:</span>
            <span class="n">locus_res</span> <span class="o">=</span> <span class="n">curr_spl</span><span class="o">.</span><span class="n">loci</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">locus_id</span><span class="p">]</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model_method_name</span><span class="p">]</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">locus_res</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

<div class="viewcode-block" id="LocusClassifier.fit"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusClassifier.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_dataset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the model using train_dataset as training data and their status as target values.</span>

<span class="sd">        :param train_dataset: The list of MSISample containing the locus to classify and in LocusRes the data of the selected method and the status ecpected.</span>
<span class="sd">        :type test_dataset: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train_dataset</span> <span class="o">=</span> <span class="n">train_dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_usable_train_dataset</span> <span class="o">=</span> <span class="p">[</span><span class="n">spl</span> <span class="k">for</span> <span class="n">spl</span> <span class="ow">in</span> <span class="n">train_dataset</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_method_name</span> <span class="ow">in</span> <span class="n">spl</span><span class="o">.</span><span class="n">loci</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">locus_id</span><span class="p">]</span><span class="o">.</span><span class="n">results</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_train_data</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_train_labels</span><span class="p">())</span></div>

<div class="viewcode-block" id="LocusClassifier.predict"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusClassifier.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test_dataset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict the status of the locus in the list of samples.</span>

<span class="sd">        :param test_dataset: The list of MSISample containing the locus to classify and in LocusRes the data of the selected method. These samples must already be filtered, for eaxmple on count of elements in length distribution.</span>
<span class="sd">        :type test_dataset: list</span>
<span class="sd">        :return: The predicted class for the selected locus in each sample.</span>
<span class="sd">        :rtype: np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span> <span class="o">=</span> <span class="n">test_dataset</span>
        <span class="n">test_min_len</span><span class="p">,</span> <span class="n">test_max_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_min_max_len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_method_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test_min_len</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_len</span> <span class="ow">or</span> <span class="n">test_max_len</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_len</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train_dataset</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_test_data</span><span class="p">())</span></div>

<div class="viewcode-block" id="LocusClassifier.predict_proba"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusClassifier.predict_proba">[docs]</a>    <span class="k">def</span> <span class="nf">predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test_dataset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return estimated probabilities for the test_dataset.</span>

<span class="sd">        :param test_dataset: The list of MSISample containing the locus to classify and in LocusRes the data of the selected method. These samples must already be filtered, for eaxmple on count of elements in length distribution.</span>
<span class="sd">        :type test_dataset: list</span>
<span class="sd">        :return: The estimated probabilities for the test_dataset.</span>
<span class="sd">        :rtype: np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span> <span class="o">=</span> <span class="n">test_dataset</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_test_data</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">_get_scores</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pred_labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return confidence scores for the predictions of the test_dataset.</span>

<span class="sd">        :param pred_labels: The list of predicted status for the test_dataset.</span>
<span class="sd">        :type pred_labels: list</span>
<span class="sd">        :return: The scores for the predictions. The values are between 0 and 1.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">proba_idx_by_label</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">classes_</span><span class="p">)}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">proba</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span><span class="p">)</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">spl_proba</span><span class="p">[</span><span class="n">proba_idx_by_label</span><span class="p">[</span><span class="n">spl_label</span><span class="p">]],</span> <span class="mi">6</span><span class="p">)</span> <span class="k">for</span> <span class="n">spl_proba</span><span class="p">,</span> <span class="n">spl_label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">proba</span><span class="p">,</span> <span class="n">pred_labels</span><span class="p">)]</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">spl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">scores</span>

<div class="viewcode-block" id="LocusClassifier.set_status"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusClassifier.set_status">[docs]</a>    <span class="k">def</span> <span class="nf">set_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test_dataset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set status and score for the selected locus in the list of samples.</span>

<span class="sd">        :param test_dataset: The list of MSISample containing the locus to classify and in LocusRes the data of the selected method. These samples must already be filtered, for eaxmple on count of elements in length distribution.</span>
<span class="sd">        :type test_dataset: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span> <span class="o">=</span> <span class="n">test_dataset</span>
        <span class="n">pred_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">)</span>
        <span class="n">pred_scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_scores</span><span class="p">(</span><span class="n">pred_labels</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">sample</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pred_labels</span><span class="p">,</span> <span class="n">pred_scores</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sample</span><span class="o">.</span><span class="n">loci</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">locus_id</span><span class="p">]</span><span class="o">.</span><span class="n">results</span><span class="p">:</span>  <span class="c1"># If the method does not exist in locus results</span>
                <span class="n">sample</span><span class="o">.</span><span class="n">loci</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">locus_id</span><span class="p">]</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">method_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">LocusRes</span><span class="p">(</span><span class="n">Status</span><span class="o">.</span><span class="n">none</span><span class="p">)</span>
            <span class="n">locus_res</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">loci</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">locus_id</span><span class="p">]</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">method_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method_name</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_method_name</span><span class="p">:</span>  <span class="c1"># If data used in prediction come from an other method</span>
                <span class="n">locus_res</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;data_source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_method_name</span>
            <span class="n">locus_res</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">label</span>
            <span class="n">locus_res</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="n">score</span></div></div>


<div class="viewcode-block" id="getNbSupporting"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.getNbSupporting">[docs]</a><span class="k">def</span> <span class="nf">getNbSupporting</span><span class="p">(</span><span class="n">report</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;model&quot;</span><span class="p">,</span> <span class="n">loci</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the number of samples by locus class.</span>

<span class="sd">    :param in_report: List of MSI samples.</span>
<span class="sd">    :type in_report: list</span>
<span class="sd">    :param method: Evaluated method.</span>
<span class="sd">    :type method: str</span>
<span class="sd">    :param loci: List of evaluated loci.</span>
<span class="sd">    :type loci: list</span>
<span class="sd">    :return: The number of samples by locus class. Each item is dict with following keys: locus_name, locus_id, status and support.</span>
<span class="sd">    :rtype: list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Init loci from report if the argument is None</span>
    <span class="k">if</span> <span class="n">loci</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">loci</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">spl</span> <span class="ow">in</span> <span class="n">report</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">locus_id</span> <span class="ow">in</span> <span class="n">spl</span><span class="o">.</span><span class="n">loci</span><span class="p">:</span>
                <span class="n">loci</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">locus_id</span><span class="p">)</span>
    <span class="c1"># Get count by status by locus</span>
    <span class="n">nb_by_locus</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">spl</span> <span class="ow">in</span> <span class="n">report</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">locus_id</span> <span class="ow">in</span> <span class="n">loci</span><span class="p">:</span>
            <span class="n">locus</span> <span class="o">=</span> <span class="n">spl</span><span class="o">.</span><span class="n">loci</span><span class="p">[</span><span class="n">locus_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">locus_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nb_by_locus</span><span class="p">:</span>
                <span class="n">nb_by_locus</span><span class="p">[</span><span class="n">locus_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;locus_name&quot;</span><span class="p">:</span> <span class="n">locus</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="s2">&quot;supp_by_status&quot;</span><span class="p">:</span> <span class="p">{</span><span class="n">elt</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">Status</span><span class="o">.</span><span class="n">authorizedValues</span><span class="p">()}</span>
                <span class="p">}</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">locus</span><span class="o">.</span><span class="n">results</span><span class="p">:</span>
                <span class="n">locus_status</span> <span class="o">=</span> <span class="n">locus</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">.</span><span class="n">status</span>
                <span class="n">nb_by_locus</span><span class="p">[</span><span class="n">locus_id</span><span class="p">][</span><span class="s2">&quot;supp_by_status&quot;</span><span class="p">][</span><span class="n">locus_status</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># To list</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">locus_id</span><span class="p">,</span> <span class="n">locus_info</span> <span class="ow">in</span> <span class="n">nb_by_locus</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">status</span><span class="p">,</span> <span class="n">support</span> <span class="ow">in</span> <span class="n">locus_info</span><span class="p">[</span><span class="s2">&quot;supp_by_status&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">counts</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s2">&quot;locus_id&quot;</span><span class="p">:</span> <span class="n">locus_id</span><span class="p">,</span>
                <span class="s2">&quot;locus_name&quot;</span><span class="p">:</span> <span class="n">locus_info</span><span class="p">[</span><span class="s2">&quot;locus_name&quot;</span><span class="p">],</span>
                <span class="s2">&quot;status&quot;</span><span class="p">:</span> <span class="n">status</span><span class="p">,</span>
                <span class="s2">&quot;support&quot;</span><span class="p">:</span> <span class="n">support</span>
            <span class="p">})</span>
    <span class="k">return</span> <span class="n">counts</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, Frédéric Escudié.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>